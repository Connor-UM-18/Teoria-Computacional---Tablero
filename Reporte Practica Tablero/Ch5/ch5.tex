\chapter{Anexos}
\lstset{
    language=C,
    basicstyle=\ttfamily\small\color{black},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=8pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    rulecolor=\color{magenta},
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    title=\lstname,
    escapeinside={\%*}{*)},
    keywordstyle=\color{blue},
    commentstyle=\color{red},
    stringstyle=\color{orange},
    morecomment=[l][\color{red}]{\#},
    otherkeywords={=,!,<,>,*,+,-,&,|,^,~},
    numbers=left,                   % Coloca los números de línea a la izquierda
    numberstyle=\tiny\color{black}, % Estilo de los números de línea
    stepnumber=1,    % Incremento en el que se muestran los números de línea
    numbersep=8pt
}
\section{LATEX de exte proyecto}
Dirección Overleaf: \url{https://www.overleaf.com/3411646862zgynbbsnckcd}\newline
Dirección GitHub: \url{}\newline

\section{Main.py}
El código main solo es el programa principal que nos redireccionara a los archivos .py correspondientes a su asignmación. \newline
\\
\begin{lstlisting}
#Teoria de la computacion
#Buscador de palabras
#Alumno: Connor Urbano Mendoza
import os
import subprocess

def menu_piezas():
    cantidad = int(input("Ingrese la cantidad de piezas a invocar (mínimo 1, máximo 2)\n--> "))
    if cantidad < 1 or cantidad > 2:
        print("\nCantidad inválida. Por favor, ingrese 1 o 2.")
        return menu_piezas()  # Llamada recursiva si la cantidad es inválida
    else:
        return cantidad

def menu_recorrido(cantidad_piezas):
    #config==1 es para recorrido aleatorio
    #config==2 es para recorido manual
    if cantidad_piezas==1:
        #1 pieza
        opcion = int(input("Seleccione una opción:\n1. Generar recorrido aleatoriamente.\n2. Ingresar recorrido manualmente.\nOpción: "))
        if opcion == 1:
            return 1  # Opción de generar recorrido aleatoriamente
        elif opcion == 2:
            return 2  # Opción de ingresar recorrido manualmente
        else:
            print("Opción inválida. Por favor, seleccione 1 o 2.")
            return menu_recorrido(cantidad_piezas)  # Llamada recursiva si la opción es inválida
    else:
        #2 piezas
        opcion = int(input("Seleccione una opción:\n1. Aleatorio vs Aleatorio.\n2. Manual vs Aleatorio.\n3. Manual vs Manual.\nOpción: "))
        if opcion == 1:
            return 3  # Opción de generar recorrido aleatoriamente vs aleatoriamente
        elif opcion == 2:
            return 4  # Opción de ingresar recorrido manualmente vs aleatoriamente
        elif opcion == 3:
            return 5  # Opción de ingresar recorrido manualmente vs manualmente
        else:
            print("Opción inválida. Por favor, seleccione 1, 2 o 3.")
            return menu_recorrido(cantidad_piezas)  # Llamada recursiva si la opción es inválida
    
#Main del ciclo del juego
# Obtener directorio actual
directorio_actual = os.path.dirname(os.path.abspath(__file__))
cantidad_piezas = menu_piezas()
print("\nCantidad de piezas seleccionadas:", cantidad_piezas)
config = menu_recorrido(cantidad_piezas)
x=0
#Posibles configuraciones: 1,2,3,4 o 5.
if config == 1:#A
    archivo_py = os.path.join(directorio_actual, "main1.py")
    resultado = subprocess.run(["python", archivo_py])
    os.system('cls' if os.name == 'nt' else 'clear')
    codigo_salida = resultado.returncode
    x=1
    #print(codigo_salida)
elif config == 2:#Manual
    archivo_py = os.path.join(directorio_actual, "main2.py")
    resultado = subprocess.run(["python", archivo_py])
    os.system('cls' if os.name == 'nt' else 'clear')
    codigo_salida = resultado.returncode
    x=1
    #print(codigo_salida)
elif config == 3:#AvsA
    archivo_py = os.path.join(directorio_actual, "main3.py")
    resultado =subprocess.run(["python", archivo_py])
    os.system('cls' if os.name == 'nt' else 'clear')
    codigo_salida = resultado.returncode
    x=2
    #print(codigo_salida)
elif config == 4:#ManualvsA
    archivo_py = os.path.join(directorio_actual, "main4.py")
    resultado =subprocess.run(["python", archivo_py])
    os.system('cls' if os.name == 'nt' else 'clear')
    codigo_salida = resultado.returncode
    x=2
    #print(codigo_salida)
elif config == 5:#ManualvsManual
    archivo_py = os.path.join(directorio_actual, "main5.py")
    resultado =subprocess.run(["python", archivo_py])
    os.system('cls' if os.name == 'nt' else 'clear')
    codigo_salida = resultado.returncode
    x=2
    #print(codigo_salida)

if codigo_salida == 3:
    archivo_py = os.path.join(directorio_actual, "graficador_grande.py")
    subprocess.run(["python", archivo_py,(str(x))])
else:
    archivo_py = os.path.join(directorio_actual, "graficador.py")
    subprocess.run(["python", archivo_py,(str(x))])
print("termino")
\end{lstlisting}

\section{Main1.py}
El código main solo es el programa principal que nos redireccionara a los archivos .py correspondientes a su asignmación. \newline
\\
\begin{lstlisting}
#Teoria de la computacion
#Buscador de palabras
#Alumno: Connor Urbano Mendoza

import random
import pygame
import random
import os

pygame.init() #Acceso al paquete pygame
#Ancho
WIDTH = 1000
#Altura
HEIGHT = 700
screen = pygame.display.set_mode((WIDTH,HEIGHT)) #Tamanio de ventana a imprimir
pygame.display.set_caption('Problema del Ajedrez')
font = pygame.font.Font('freesansbold.ttf',20)#Tipo de fuente 1 del juego
big_font= pygame.font.Font('freesansbold.ttf',50)#Tipo de fuente 2 del juego
timer = pygame.time.Clock()#velocidad de actualizacion de nuestro juego a 60 fps
fps=60

#NFA de estados
tablaEstados = {
    '1' : {'R': {'2','5'}, 'N': '6'},
    '2' : {'R': {'5','7'}, 'N': {'1','6','3'}},
    '3' : {'R': {'2','7','4'}, 'N': {'6','8'}},
    '4' : {'R': '7', 'N': {'3','8'}},
    '5' : {'R': {'2','10'}, 'N': {'1','6','9'}},
    '6' : {'R': {'2','5','7','10'}, 'N': {'1','3','9','11'}},
    '7' : {'R': {'2','4','10','12'}, 'N': {'3','6','8','11'}},
    '8' : {'R': {'4','7','12'}, 'N': {'3','11'}},
    '9' : {'R': {'5','10','13'}, 'N': {'6','14'}},
    '10' : {'R': {'5','7','13','15'}, 'N': {'6','9','11','14'}},
    '11' : {'R': {'7','10','12','15'}, 'N': {'6','8','14','16'}},
    '12' : {'R': {'7','15'}, 'N': {'8','11','16'}},
    '13' : {'R': '10', 'N': {'9','14'}},
    '14' : {'R': {'13','10','15'}, 'N': {'9','11'}},
    '15' : {'R': {'10','12'}, 'N': {'11','14','16'}},
    '16' : {'R': {'12','15'}, 'N': '11'}#Estado 16 es el estado Final.
}

#Variables e imagenes del juego
pieza_blanca = ['king']
posicion_blanca =[(235,85)]

#Variables de turnos cambiantes
turn_step = 0
selection= 100
#Cargar imagenes en juego
rey_blanco = pygame.image.load('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\img\\white_king.png')
rey_blanco = pygame.transform.scale(rey_blanco,(80,80))

imagen_blanca = [rey_blanco]

lista_piezas = ['king']

#ver variables/contador flash
boton_presionado = False

def dibujar_boton():
    boton_width = 150
    boton_height = 45
    boton_x = (WIDTH - boton_width) // 2
    boton_y = (HEIGHT - boton_height - 20)+17

    # Dibujar el botón como un rectángulo en la pantalla
    boton_rect=pygame.Rect(boton_x, boton_y, boton_width, boton_height)
    pygame.draw.rect(screen, (0, 255, 0), (boton_x, boton_y, boton_width, boton_height))
    texto = font.render("Siguiente", True, (0, 0, 0))
    texto_rect = texto.get_rect(center=(boton_x + boton_width // 2, boton_y + boton_height // 2))
    screen.blit(texto, texto_rect)
    return boton_rect
    
#Funcion para dibujar tablero
def dibujar_tablero():
    cuadro_size = 150  # Tamaño de cada cuadro del tablero
    tablero_width = 4 * cuadro_size  # Ancho total del tablero
    tablero_height = 4 * cuadro_size  # Altura total del tablero
    tablero_x = (WIDTH - tablero_width) // 2  # Posición X para centrar el tablero
    tablero_y = (HEIGHT - tablero_height) // 2  # Posición Y para centrar el tablero
    
    numero_color = 'white'  # Color del número de casilla

    font = pygame.font.Font(None, 24)  # Fuente y tamaño del número de casilla

    for i in range(16):  # Iterar 16 veces para un tablero de 4x4
        columna = i % 4
        fila = i // 4
        x = tablero_x + columna * cuadro_size
        y = tablero_y + fila * cuadro_size
        if fila % 2 == 0:
            color = 'black' if columna % 2 == 0 else 'red'
        else:
            color = 'red' if columna % 2 == 0 else 'black'
        pygame.draw.rect(screen, color, [x, y, cuadro_size, cuadro_size])
        pygame.draw.rect(screen, 'white', [x, y, cuadro_size, cuadro_size], 2)  # Agregar borde de color blanco
        numero_texto = font.render(str(i + 1), True, numero_color)  # Crear superficie de texto con el número
        numero_rect = numero_texto.get_rect(center=((x + cuadro_size // 2)-60, y + 20))  # Posición del número en la parte superior del recuadro
        screen.blit(numero_texto, numero_rect)  # Pegar el número en la pantalla

#Funcion para dibujar piezas
def dibujar_piezas():
    index=lista_piezas.index('king')
    if pieza_blanca[0]=='king':     
        
        screen.blit(imagen_blanca[index],(posicion_blanca[0][0],posicion_blanca[0][1]))
           
def recorrer_estados(tabla_estados, cadena):
    # Función para obtener todos los recorridos posibles
    def obtener_recorridos(estado_actual, simbolos_restantes, recorrido_actual):
        if not simbolos_restantes:
            recorridos.append(recorrido_actual)
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    # Función para obtener los recorridos válidos hasta el estado final
    def obtener_recorridos_finales(estado_actual, simbolos_restantes, recorrido_actual):
        if estado_actual == '16':
            recorridos_finales.append(recorrido_actual)
            return

        if not simbolos_restantes:
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos_finales(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    # Obtener recorridos posibles
    recorridos = []
    obtener_recorridos('1', cadena, ['1'])

    # Obtener recorridos hasta el estado final
    recorridos_finales = []
    obtener_recorridos_finales('1', cadena, ['1'])

    # Guardar los recorridos en archivos de texto
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_blanca.txt', 'w') as archivo_recorridos:
        archivo_recorridos.write('Recorridos posibles:\n')
        for recorrido in recorridos:
            archivo_recorridos.write(','.join(recorrido) + '\n')

    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_blanca.txt', 'w') as archivo_recorridos_finales:
        for recorrido in recorridos_finales:
            archivo_recorridos_finales.write(','.join(recorrido) + '\n')



def seleccionar_recorrido():
    ruta_archivo = "C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_blanca.txt"
    
    with open(ruta_archivo, "r") as archivo:
        if os.path.getsize(ruta_archivo) == 0:
            print("No existen soluciones que lleguen al estado 16 con la condicion actual. Se recalculara una ruta.\n")
            nuevaruta=cadena()
            print("La nueva ruta es: "+nuevaruta)
            recorrer_estados(tablaEstados, nuevaruta)
            print('Se almacenaron las nuevas salidas de los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
            
            return seleccionar_recorrido()
            
        lineas = archivo.readlines()
        
        # Seleccionar una línea aleatoria
        recorrido_seleccionado = random.choice(lineas)
        
        # Eliminar los espacios en blanco y saltos de línea
        recorrido_seleccionado = recorrido_seleccionado.strip()
        
        return recorrido_seleccionado

def cadenaRandom(numero): #Genera un string de forma random 
    auxiliar = '' #Variable auxiliar
    for i in range(numero):
        x = random.randint(1, 2) #Función para generar un resultado random de una lista
        if x % 2 == 0:
            auxiliar = auxiliar + "R"
        else:
            auxiliar = auxiliar + "N"
    return auxiliar

def cadena():
    numero = random.randint(4,10)
    print('\nTamanio de cadena escogido aleatoriamente ['+str(numero)+']\nTambien se generaran las transiciones R y N aleatoriamente.\n')
    cad = cadenaRandom(numero) #Se genera de forma aleatoria del 1-10
    print('\nLa cadena o ruta a seguir escogida aleatoriamente sera: '+cad+'\n')
    return cad

def calcular_coordenadas(estado):
    cuadro_size = 150  # Tamaño de cada cuadro del tablero
    tablero_width = 4 * cuadro_size  # Ancho total del tablero
    tablero_height = 4 * cuadro_size  # Altura total del tablero
    tablero_x = (WIDTH - tablero_width) // 2  # Posición X para centrar el tablero
    tablero_y = (HEIGHT - tablero_height) // 2  # Posición Y para centrar el tablero
    fila = (estado - 1) // 4  # Calcular la fila del estado
    columna = (estado - 1) % 4  # Calcular la columna del estado
    x = tablero_x + columna * cuadro_size  # Calcular la coordenada X del estado
    y = tablero_y + fila * cuadro_size  # Calcular la coordenada Y del estado
    return ((x+33), y+33)  # Devolver las coordenadas como una tupla


#Main del ciclo del juego 1
ruta=cadena()#Solicitamos la cadena generada aleatoriamente.
recorrer_estados(tablaEstados, ruta)
print('\nEn este punto el programa almaceno en la salidas los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
recorrido = seleccionar_recorrido()#Este fue el recorrido que se escogio de manera aleatoria
with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt', 'w') as archivo:
    archivo.write(ruta)
print("\nRecorrido seleccionado:", recorrido)
print("\nVea la parte grafica.")
lista_estados = [int(num) for num in recorrido.split(",")]

coordenadas=(235,85)
nueva_coordenada=(0,0)
run=True
contador=1
while run:
    timer.tick(fps)
    screen.fill('dark gray')
    dibujar_tablero()
    dibujar_piezas()
    boton_rect = dibujar_boton()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            mouse_pos = pygame.mouse.get_pos()
            if boton_rect.collidepoint(mouse_pos):  # Verificar si se hizo clic en el botón
                
                nueva_coordenada = calcular_coordenadas(lista_estados[contador])
                
                if turn_step <= 1:
                    if coordenadas in posicion_blanca:
                        selection = posicion_blanca.index(coordenadas)
                        if turn_step == 0:
                            turn_step = 1
                        
                    if turn_step==1 and selection != 100:
                        posicion_blanca[0] = nueva_coordenada
                        
                        selection = 100
                        contador += 1
                        coordenadas = nueva_coordenada
                        turn_step=0

    pygame.display.flip()


pygame.quit()

\end{lstlisting}


\section{Main2.py}
El código main solo es el programa principal que nos redireccionara a los archivos .py correspondientes a su asignmación. \newline
\\
\begin{lstlisting}
#Teoria de la computacion
#Buscador de palabras
#Alumno: Connor Urbano Mendoza

import random
import pygame
import random
import os
import sys

pygame.init() #Acceso al paquete pygame
#Ancho
WIDTH = 1000
#Altura
HEIGHT = 700
screen = pygame.display.set_mode((WIDTH,HEIGHT)) #Tamanio de ventana a imprimir
pygame.display.set_caption('Problema del Ajedrez')
font = pygame.font.Font('freesansbold.ttf',20)#Tipo de fuente 1 del juego
big_font= pygame.font.Font('freesansbold.ttf',50)#Tipo de fuente 2 del juego
timer = pygame.time.Clock()#velocidad de actualizacion de nuestro juego a 60 fps
fps=60

#NFA de estados
tablaEstados = {
    '1' : {'R': {'2','5'}, 'N': '6'},
    '2' : {'R': {'5','7'}, 'N': {'1','6','3'}},
    '3' : {'R': {'2','7','4'}, 'N': {'6','8'}},
    '4' : {'R': '7', 'N': {'3','8'}},
    '5' : {'R': {'2','10'}, 'N': {'1','6','9'}},
    '6' : {'R': {'2','5','7','10'}, 'N': {'1','3','9','11'}},
    '7' : {'R': {'2','4','10','12'}, 'N': {'3','6','8','11'}},
    '8' : {'R': {'4','7','12'}, 'N': {'3','11'}},
    '9' : {'R': {'5','10','13'}, 'N': {'6','14'}},
    '10' : {'R': {'5','7','13','15'}, 'N': {'6','9','11','14'}},
    '11' : {'R': {'7','10','12','15'}, 'N': {'6','8','14','16'}},
    '12' : {'R': {'7','15'}, 'N': {'8','11','16'}},
    '13' : {'R': '10', 'N': {'9','14'}},
    '14' : {'R': {'13','10','15'}, 'N': {'9','11'}},
    '15' : {'R': {'10','12'}, 'N': {'11','14','16'}},
    '16' : {'R': {'12','15'}, 'N': '11'}#Estado 16 es el estado Final.
}

#Variables e imagenes del juego
pieza_blanca = ['king']
posicion_blanca =[(235,85)]

#
turn_step = 0
selection= 100
#Cargar imagenes en juego
rey_blanco = pygame.image.load('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\img\\white_king.png')
rey_blanco = pygame.transform.scale(rey_blanco,(80,80))

imagen_blanca = [rey_blanco]

lista_piezas = ['king']
#ver variables/contador flash


boton_presionado = False

def dibujar_boton():
    boton_width = 150
    boton_height = 45
    boton_x = (WIDTH - boton_width) // 2
    boton_y = (HEIGHT - boton_height - 20)+17

    # Dibujar el botón como un rectángulo en la pantalla
    boton_rect=pygame.Rect(boton_x, boton_y, boton_width, boton_height)
    pygame.draw.rect(screen, (0, 255, 0), (boton_x, boton_y, boton_width, boton_height))
    texto = font.render("Siguiente", True, (0, 0, 0))
    texto_rect = texto.get_rect(center=(boton_x + boton_width // 2, boton_y + boton_height // 2))
    screen.blit(texto, texto_rect)
    return boton_rect
    
#Funcion para dibujar tablero
def dibujar_tablero():
    cuadro_size = 150  # Tamaño de cada cuadro del tablero
    tablero_width = 4 * cuadro_size  # Ancho total del tablero
    tablero_height = 4 * cuadro_size  # Altura total del tablero
    tablero_x = (WIDTH - tablero_width) // 2  # Posición X para centrar el tablero
    tablero_y = (HEIGHT - tablero_height) // 2  # Posición Y para centrar el tablero
    
    numero_color = 'white'  # Color del número de casilla

    font = pygame.font.Font(None, 24)  # Fuente y tamaño del número de casilla

    for i in range(16):  # Iterar 16 veces para un tablero de 4x4
        columna = i % 4
        fila = i // 4
        x = tablero_x + columna * cuadro_size
        y = tablero_y + fila * cuadro_size
        if fila % 2 == 0:
            color = 'black' if columna % 2 == 0 else 'red'
        else:
            color = 'red' if columna % 2 == 0 else 'black'
        pygame.draw.rect(screen, color, [x, y, cuadro_size, cuadro_size])
        pygame.draw.rect(screen, 'white', [x, y, cuadro_size, cuadro_size], 2)  # Agregar borde de color blanco
        numero_texto = font.render(str(i + 1), True, numero_color)  # Crear superficie de texto con el número
        numero_rect = numero_texto.get_rect(center=((x + cuadro_size // 2)-60, y + 20))  # Posición del número en la parte superior del recuadro
        screen.blit(numero_texto, numero_rect)  # Pegar el número en la pantalla

#Funcion para dibujar piezas
def dibujar_piezas():
    index=lista_piezas.index('king')
    if pieza_blanca[0]=='king':     
        
        screen.blit(imagen_blanca[index],(posicion_blanca[0][0],posicion_blanca[0][1]))
  
def recorrer_estados(tabla_estados, cadena):
    
    # Función para obtener todos los recorridos posibles
    def obtener_recorridos(estado_actual, simbolos_restantes, recorrido_actual, archivo_recorridos):
        if not simbolos_restantes:
            archivo_recorridos.write(','.join(recorrido_actual) + '\n')
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos(
                    estado_siguiente,
                    simbolos_restantes[1:],
                    recorrido_actual + [estado_siguiente],
                    archivo_recorridos
                )

    # Función para obtener los recorridos válidos hasta el estado final
    def obtener_recorridos_finales(estado_actual, simbolos_restantes, recorrido_actual, archivo_recorridos_finales):
        if estado_actual == '16':
            archivo_recorridos_finales.write(','.join(recorrido_actual) + '\n')
            return

        if not simbolos_restantes:
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos_finales(
                    estado_siguiente,
                    simbolos_restantes[1:],
                    recorrido_actual + [estado_siguiente],
                    archivo_recorridos_finales
                )

    # Obtener recorridos posibles
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_blanca.txt', 'w') as archivo_recorridos:
        obtener_recorridos('1', cadena, ['1'], archivo_recorridos)

    # Obtener recorridos hasta el estado final
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_blanca.txt', 'w') as archivo_recorridos_finales:
        obtener_recorridos_finales('1', cadena, ['1'], archivo_recorridos_finales)


def seleccionar_recorrido():
    ruta_archivo = "C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_blanca.txt"
    
    with open(ruta_archivo, "r") as archivo:
        if os.path.getsize(ruta_archivo) == 0:
            print("No existen soluciones que lleguen al estado 16 con la condicion actual. Ingrese nueva ruta.")
            nuevaruta=cadena()
            print("La nueva ruta es: "+nuevaruta)
            recorrer_estados(tablaEstados, nuevaruta)
            print('Se almacenaron las nuevas salidas de los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
            lineas = archivo.readlines()
            # Seleccionar una línea aleatoria
            recorrido_seleccionado = random.choice(lineas)
            
            # Eliminar los espacios en blanco y saltos de línea
            recorrido_seleccionado = recorrido_seleccionado.strip()
            
            return recorrido_seleccionado
        
            
        lineas = archivo.readlines()
        
        # Seleccionar una línea aleatoria
        recorrido_seleccionado = random.choice(lineas)
        
        # Eliminar los espacios en blanco y saltos de línea
        recorrido_seleccionado = recorrido_seleccionado.strip()
        
        return recorrido_seleccionado

def cadena():
    while 1:
        ruta = input("Ingrese la cadena usando las transiciones R y N.\n").upper()
        if len(ruta) > 10:
            print("\nNo es posible introducir más de 10 caracteres en la cadena de recorrido para animacion. Desea seguir de igual forma?(Ya no se animara, se procedera al arbol)")
            respuesta = int(input("1. Si.\n2. No.\n"))
            if respuesta == 1:
                break
            else:
                pass
        else:
            print()
            break
    print('\nTamanio de cadena escogido ['+str(len(ruta))+'].')
    print('\nLa cadena o ruta a seguir escogida sera: '+ruta+'\n')
    return ruta

def calcular_coordenadas(estado):
    cuadro_size = 150  # Tamaño de cada cuadro del tablero
    tablero_width = 4 * cuadro_size  # Ancho total del tablero
    tablero_height = 4 * cuadro_size  # Altura total del tablero
    tablero_x = (WIDTH - tablero_width) // 2  # Posición X para centrar el tablero
    tablero_y = (HEIGHT - tablero_height) // 2  # Posición Y para centrar el tablero
    fila = (estado - 1) // 4  # Calcular la fila del estado
    columna = (estado - 1) % 4  # Calcular la columna del estado
    x = tablero_x + columna * cuadro_size  # Calcular la coordenada X del estado
    y = tablero_y + fila * cuadro_size  # Calcular la coordenada Y del estado
    
    return ((x+33), y+33)  # Devolver las coordenadas como una tupla



#Main del ciclo del juego 2
ruta=cadena()#Solicitamos la cadena generada aleatoriamente.
with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt', 'w') as archivo:
    archivo.write(ruta)
if len(ruta)> 10:
    input("Presione Enter para continuar...")
    sys.exit(3)    
recorrer_estados(tablaEstados, ruta)
print('\nEn este punto el programa almaceno en la salidas los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
recorrido = seleccionar_recorrido()#Este fue el recorrido que se escogio de manera aleatoria

with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt', 'w') as archivo:
    archivo.write(ruta)

print("\nRecorrido seleccionado:", recorrido)
print("\nVea la parte grafica.")
lista_estados = [int(num) for num in recorrido.split(",")]

coordenadas=(235,85)
nueva_coordenada=(0,0)
run=True
contador=1
while run:
    timer.tick(fps)
    screen.fill('dark gray')
    dibujar_tablero()
    dibujar_piezas()
    boton_rect = dibujar_boton()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            mouse_pos = pygame.mouse.get_pos()
            if boton_rect.collidepoint(mouse_pos):  # Verificar si se hizo clic en el botón
                
                nueva_coordenada = calcular_coordenadas(lista_estados[contador])
                
                if turn_step <= 1:
                    if coordenadas in posicion_blanca:
                        selection = posicion_blanca.index(coordenadas)
                        if turn_step == 0:
                            turn_step = 1
                        
                    if turn_step==1 and selection != 100:
                        posicion_blanca[0] = nueva_coordenada
                        selection = 100
                        contador += 1
                        coordenadas = nueva_coordenada
                        turn_step=0

    pygame.display.flip()


pygame.quit()

\end{lstlisting}


\section{Main3.py}
El código main solo es el programa principal que nos redireccionara a los archivos .py correspondientes a su asignmación. \newline
\\
\begin{lstlisting}
#Teoria de la computacion
#Buscador de palabras
#Alumno: Connor Urbano Mendoza

import random
import pygame
import random
import os

pygame.init() #Acceso al paquete pygame
#Ancho
WIDTH = 1000
#Altura
HEIGHT = 700
screen = pygame.display.set_mode((WIDTH,HEIGHT)) #Tamanio de ventana a imprimir
pygame.display.set_caption('Problema del Ajedrez')
font = pygame.font.Font('freesansbold.ttf',20)#Tipo de fuente 1 del juego
big_font= pygame.font.Font('freesansbold.ttf',50)#Tipo de fuente 2 del juego
timer = pygame.time.Clock()#velocidad de actualizacion de nuestro juego a 60 fps
fps=60

#NFA de estados
tablaEstados = {
    '1' : {'R': {'2','5'}, 'N': '6'},
    '2' : {'R': {'5','7'}, 'N': {'1','6','3'}},
    '3' : {'R': {'2','7','4'}, 'N': {'6','8'}},
    '4' : {'R': '7', 'N': {'3','8'}},
    '5' : {'R': {'2','10'}, 'N': {'1','6','9'}},
    '6' : {'R': {'2','5','7','10'}, 'N': {'1','3','9','11'}},
    '7' : {'R': {'2','4','10','12'}, 'N': {'3','6','8','11'}},
    '8' : {'R': {'4','7','12'}, 'N': {'3','11'}},
    '9' : {'R': {'5','10','13'}, 'N': {'6','14'}},
    '10' : {'R': {'5','7','13','15'}, 'N': {'6','9','11','14'}},
    '11' : {'R': {'7','10','12','15'}, 'N': {'6','8','14','16'}},
    '12' : {'R': {'7','15'}, 'N': {'8','11','16'}},
    '13' : {'R': '10', 'N': {'9','14'}},
    '14' : {'R': {'13','10','15'}, 'N': {'9','11'}},
    '15' : {'R': {'10','12'}, 'N': {'11','14','16'}},
    '16' : {'R': {'12','15'}, 'N': '11'}#Estado 16 es el estado Final.
}

#Variables e imagenes del juego
pieza_blanca = ['king']
pieza_negra = ['king']
posicion_blanca =[(235,85)]
posicion_negra =[(683,85)]

#
turn_step = 0
selection= 100
valid_moves_for1 =[]
#Cargar imagenes en juego
rey_blanco = pygame.image.load('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\img\\white_king.png')
rey_blanco = pygame.transform.scale(rey_blanco,(80,80))
rey_negro = pygame.image.load('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\img\\black_king.png')
rey_negro = pygame.transform.scale(rey_negro,(80,80))

imagen_blanca = [rey_blanco]
imagen_negra=[rey_negro]

lista_piezas = ['king']
#ver variables/contador flash


boton_presionado = False

def dibujar_boton():
    boton_width = 150
    boton_height = 45
    boton_x = (WIDTH - boton_width) // 2
    boton_y = (HEIGHT - boton_height - 20)+17

    # Dibujar el botón como un rectángulo en la pantalla
    boton_rect=pygame.Rect(boton_x, boton_y, boton_width, boton_height)
    pygame.draw.rect(screen, (0, 255, 0), (boton_x, boton_y, boton_width, boton_height))
    texto = font.render("Siguiente", True, (0, 0, 0))
    texto_rect = texto.get_rect(center=(boton_x + boton_width // 2, boton_y + boton_height // 2))
    screen.blit(texto, texto_rect)
    return boton_rect
    
#Funcion para dibujar tablero
def dibujar_tablero():
    cuadro_size = 150  # Tamaño de cada cuadro del tablero
    tablero_width = 4 * cuadro_size  # Ancho total del tablero
    tablero_height = 4 * cuadro_size  # Altura total del tablero
    tablero_x = (WIDTH - tablero_width) // 2  # Posición X para centrar el tablero
    tablero_y = (HEIGHT - tablero_height) // 2  # Posición Y para centrar el tablero
    
    numero_color = 'white'  # Color del número de casilla

    font = pygame.font.Font(None, 24)  # Fuente y tamaño del número de casilla

    for i in range(16):  # Iterar 16 veces para un tablero de 4x4
        columna = i % 4
        fila = i // 4
        x = tablero_x + columna * cuadro_size
        y = tablero_y + fila * cuadro_size
        if fila % 2 == 0:
            color = 'black' if columna % 2 == 0 else 'red'
        else:
            color = 'red' if columna % 2 == 0 else 'black'
        pygame.draw.rect(screen, color, [x, y, cuadro_size, cuadro_size])
        pygame.draw.rect(screen, 'white', [x, y, cuadro_size, cuadro_size], 2)  # Agregar borde de color blanco
        numero_texto = font.render(str(i + 1), True, numero_color)  # Crear superficie de texto con el número
        numero_rect = numero_texto.get_rect(center=((x + cuadro_size // 2)-60, y + 20))  # Posición del número en la parte superior del recuadro
        screen.blit(numero_texto, numero_rect)  # Pegar el número en la pantalla

#Funcion para dibujar piezas
def dibujar_piezas():
    index=lista_piezas.index('king')
    if pieza_blanca[0]=='king':     
        screen.blit(imagen_blanca[index],(posicion_blanca[0][0],posicion_blanca[0][1]))
    if pieza_negra[0]=='king':     
        screen.blit(imagen_negra[index],(posicion_negra[0][0],posicion_negra[0][1]))
          
def recorrer_estados_blanca(tabla_estados, cadena,estadoInicial):
    # Función para obtener todos los recorridos posibles blanca
    def obtener_recorridos(estado_actual, simbolos_restantes, recorrido_actual):
        if not simbolos_restantes:
            recorridos2.append(recorrido_actual)
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    # Función para obtener los recorridos válidos hasta el estado final
    def obtener_recorridos_finales(estado_actual, simbolos_restantes, recorrido_actual):
        if estado_actual == '16':
            recorridos_finales.append(recorrido_actual)
            return

        if not simbolos_restantes:
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos_finales(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    
    # Obtener recorridos posibles
    recorridos2 = []
    obtener_recorridos(estadoInicial, cadena, [estadoInicial])
    # Obtener recorridos hasta el estado final
    recorridos_finales = []
    obtener_recorridos_finales(estadoInicial, cadena, [estadoInicial])
    # Guardar los recorridos en archivos de texto
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_blanca.txt', 'w') as archivo_recorridos:
        archivo_recorridos.write('Recorridos posibles:\n')
        for recorrido in recorridos2:
            archivo_recorridos.write(','.join(recorrido) + '\n')

    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_blanca.txt', 'w') as archivo_recorridos_finales:
        for recorrido in recorridos_finales:
            archivo_recorridos_finales.write(','.join(recorrido) + '\n')




def recorrer_estados_negra(tabla_estados, cadena,estadoInicial):
    # Función para obtener todos los recorridos posibles
    def obtener_recorridos(estado_actual, simbolos_restantes, recorrido_actual):
        if not simbolos_restantes:
            recorridos2.append(recorrido_actual)
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    # Función para obtener los recorridos válidos hasta el estado final
    def obtener_recorridos_finales(estado_actual, simbolos_restantes, recorrido_actual):
        if estado_actual == '13':
            recorridos_finales.append(recorrido_actual)
            return

        if not simbolos_restantes:
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos_finales(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    # Obtener recorridos posibles
    recorridos2 = []
    obtener_recorridos(estadoInicial, cadena, [estadoInicial])

    # Obtener recorridos hasta el estado final
    recorridos_finales = []
    obtener_recorridos_finales(estadoInicial, cadena, [estadoInicial])

    # Guardar los recorridos en archivos de texto
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_negra.txt', 'w') as archivo_recorridos:
        archivo_recorridos.write('Recorridos posibles:\n')
        for recorrido in recorridos2:
            archivo_recorridos.write(','.join(recorrido) + '\n')

    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_negra.txt', 'w') as archivo_recorridos_finales:
        for recorrido in recorridos_finales:
            archivo_recorridos_finales.write(','.join(recorrido) + '\n')


def seleccionar_recorrido_blanca(estadoI):
    ruta_archivo = "C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_blanca.txt"
    x=1
    while x==1:
        with open(ruta_archivo, "r+") as archivo:
            if os.path.getsize(ruta_archivo) == 0:
                print("No existen soluciones que lleguen al estado 16 con la condicion actual. Se recalculara una ruta.\n")
                nuevaruta=cadena()
                with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt', 'w') as archivo2:
                    archivo2.write(nuevaruta)
                print("La nueva ruta es: "+nuevaruta)
                recorrer_estados_blanca(tablaEstados, nuevaruta,estadoI)
                print('Se almacenaron las nuevas salidas de los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
            else:
                x=0  
                lineas = archivo.readlines()
                
                # Seleccionar una línea aleatoria
                recorrido_seleccionado = random.choice(lineas)
                
                # Eliminar los espacios en blanco y saltos de línea
                recorrido_seleccionado = recorrido_seleccionado.strip()
            
    return recorrido_seleccionado

def seleccionar_recorrido_negra(estadoI):
    ruta_archivo = "C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_negra.txt"
    x=1
    while x==1:
        with open(ruta_archivo, "r+") as archivo:
            if os.path.getsize(ruta_archivo) == 0:
                print("No existen soluciones que lleguen al estado 13 con la condicion actual. Se recalculara una ruta.\n")
                nuevaruta=cadena()
                with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_negra.txt', 'w') as archivo2:
                    archivo2.write(nuevaruta)
                print("La nueva ruta es: "+nuevaruta)
                recorrer_estados_negra(tablaEstados, nuevaruta,estadoI)
                print('Se almacenaron las nuevas salidas de los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
            else:#16
                x=0  
                lineas = archivo.readlines()
                
                # Seleccionar una línea aleatoria
                recorrido_seleccionado = random.choice(lineas)
                
                # Eliminar los espacios en blanco y saltos de línea
                recorrido_seleccionado = recorrido_seleccionado.strip()
            
    return recorrido_seleccionado

def cadenaRandom(numero): #Genera un string de forma random 
    auxiliar = '' #Variable auxiliar
    for i in range(numero):
        x = random.randint(1, 2) #Función para generar un resultado random de una lista
        if x % 2 == 0:
            auxiliar = auxiliar + "R"
        else:
            auxiliar = auxiliar + "N"
    return auxiliar

def cadena():
    numero = random.randint(4,10)
    print('\nTamanio de cadena escogido aleatoriamente ['+str(numero)+']\nTambien se generaran las transiciones R y N aleatoriamente.\n')
    cad = cadenaRandom(numero) #Se genera de forma aleatoria del 1-10
    print('\nLa cadena o ruta a seguir escogida aleatoriamente sera: '+cad+'\n')
    return cad

def calcular_coordenadas(estado):
    cuadro_size = 150  # Tamaño de cada cuadro del tablero
    tablero_width = 4 * cuadro_size  # Ancho total del tablero
    tablero_height = 4 * cuadro_size  # Altura total del tablero
    tablero_x = (WIDTH - tablero_width) // 2  # Posición X para centrar el tablero
    tablero_y = (HEIGHT - tablero_height) // 2  # Posición Y para centrar el tablero
    fila = (estado - 1) // 4  # Calcular la fila del estado
    columna = (estado - 1) % 4  # Calcular la columna del estado
    x = tablero_x + columna * cuadro_size  # Calcular la coordenada X del estado
    y = tablero_y + fila * cuadro_size  # Calcular la coordenada Y del estado
    return ((x+33), y+33)  # Devolver las coordenadas como una tupla


#Main del ciclo del juego 3
print("\n--PARA CADENA BLANCA--")
ruta_blanca=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza blanca.
recorrer_estados_blanca(tablaEstados, ruta_blanca,"1")
input()
print("\n--PARA CADENA NEGRA--")
ruta_negra=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza negra.
recorrer_estados_negra(tablaEstados, ruta_negra,"4")

print('\nEn este punto el programa almaceno en la salidas los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
recorrido_blanca = seleccionar_recorrido_blanca("1")#Este fue el recorrido que se escogio de manera aleatoria para blanca
recorrido_negra = seleccionar_recorrido_negra("4")#Este fue el recorrido que se escogio de manera aleatoria para negra

print("\nRecorrido seleccionado para blanca:", recorrido_blanca)
print("\nRecorrido seleccionado para negra:", recorrido_negra)
lista_estados_blanca = [int(num) for num in recorrido_blanca.split(",")]
lista_estados_negra = [int(num) for num in recorrido_negra.split(",")]

with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt', 'w') as archivo:
    archivo.write(ruta_blanca)
with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_negra.txt', 'w') as archivo:
    archivo.write(ruta_negra)
# Verificar el número aleatorio y determinar si se sacan piezas blancas o negras
numero_aleatorio = random.randint(1, 2)
coordenadas_blanca=(235,85)
nueva_coordenada_blanca=(0,0)
coordenadas_negra=(683,85)
nueva_coordenada_negra=(0,0)
run=True
contador_blanca=1
contador_negra=1

if numero_aleatorio == 1:
    print("\nSacan piezas blancas.")
    # Sacan piezas blancas
    while run:
        timer.tick(fps)
        screen.fill('dark gray')
        dibujar_tablero()
        dibujar_piezas()
        boton_rect = dibujar_boton()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                mouse_pos = pygame.mouse.get_pos()
                if boton_rect.collidepoint(mouse_pos):  # Verificar si se hizo clic en el botón
                    if turn_step ==4:
                        turn_step=2
                    nueva_coordenada_blanca = calcular_coordenadas(lista_estados_blanca[contador_blanca])
                    nueva_coordenada_negra = calcular_coordenadas(lista_estados_negra[contador_negra])
                    
                    if turn_step <= 1:
                        #print("Blanca")
                        if  nueva_coordenada_blanca in posicion_negra:
                            while(1):#Ciclo while, donde para salir la siguiente coordenada no pueda ser la de la colision
                                #recalculamos ruta
                                print("Colision detectada en recorrido: Recalculamos blanca")
                                ruta_blanca=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza blanca.
                                recorrer_estados_blanca(tablaEstados, ruta_blanca,str(lista_estados_blanca[contador_blanca-1]))
                                recorrido_blanca = seleccionar_recorrido_blanca(str(lista_estados_blanca[contador_blanca-1]))#Este fue el recorrido que se escogio de manera aleatoria para blanca
                                print("La ruta recalculada es: "+recorrido_blanca)
                                lista_estados_blanca = [int(num) for num in recorrido_blanca.split(",")]
                                contador_blanca=1
                                nueva_coordenada_blanca = calcular_coordenadas(lista_estados_blanca[contador_blanca])
                                if nueva_coordenada_blanca not in posicion_negra:
                                    break
                            turn_step=0
                        if coordenadas_blanca in posicion_blanca:
                            selection = posicion_blanca.index(coordenadas_blanca)
                            if turn_step == 0:
                                turn_step = 1
                        
                        if turn_step==1 and selection != 100:
                            posicion_blanca[0] = nueva_coordenada_blanca
                            
                            selection = 100
                            contador_blanca += 1
                            coordenadas_blanca = nueva_coordenada_blanca
                            turn_step=4
                    if turn_step == 2:
                        #print("Negra")
                        if  nueva_coordenada_negra in posicion_blanca:
                            while(1):
                                #recalculamos ruta
                                print("Colision detectada en recorrido: Recalculamos negra.")
                                ruta_negra=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza negra.
                                recorrer_estados_negra(tablaEstados, ruta_negra,str(lista_estados_negra[contador_negra-1]))
                                recorrido_negra = seleccionar_recorrido_negra(str(lista_estados_negra[contador_negra-1]))#Este fue el recorrido que se escogio de manera aleatoria para blanca
                                print("La ruta recalculada es: "+recorrido_negra)
                                lista_estados_negra = [int(num) for num in recorrido_negra.split(",")]
                                contador_negra=1
                                nueva_coordenada_negra = calcular_coordenadas(lista_estados_negra[contador_negra])
                                if nueva_coordenada_negra not in posicion_blanca:
                                    break
                            turn_step=2
                        if coordenadas_negra in posicion_negra:
                            selection = posicion_negra.index(coordenadas_negra)#Seleccionamos las coordenadas
                            if turn_step == 2:
                                turn_step = 3
                            
                        if turn_step==3 and selection != 100:
                            posicion_negra[0] = nueva_coordenada_negra
                            selection = 100
                            contador_negra += 1
                            coordenadas_negra = nueva_coordenada_negra
                            turn_step=0

        pygame.display.flip()
else:
    # Sacan piezas negras
    print("\nSacan piezas negras.")
    while run:
        timer.tick(fps)
        screen.fill('dark gray')
        dibujar_tablero()
        dibujar_piezas()
        boton_rect = dibujar_boton()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                mouse_pos = pygame.mouse.get_pos()
                if boton_rect.collidepoint(mouse_pos):  # Verificar si se hizo clic en el botón
                    if turn_step ==4:
                        turn_step=2
                    nueva_coordenada_blanca = calcular_coordenadas(lista_estados_blanca[contador_blanca])
                    nueva_coordenada_negra = calcular_coordenadas(lista_estados_negra[contador_negra])
                    
                    if turn_step <= 1:
                        #print("Negra")
                        if  nueva_coordenada_negra in posicion_blanca:
                            while(1):#Ciclo while, donde para salir la siguiente coordenada no pueda ser la de la colision
                                #recalculamos ruta
                                print("Colision detectada en recorrido: Recalculamos negra.")
                                ruta_negra=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza negra.
                                recorrer_estados_negra(tablaEstados, ruta_negra,str(lista_estados_negra[contador_negra-1]))
                                recorrido_negra = seleccionar_recorrido_negra(str(lista_estados_negra[contador_negra-1]))#Este fue el recorrido que se escogio de manera aleatoria para blanca
                                print("La ruta recalculada es: "+recorrido_negra)
                                lista_estados_negra = [int(num) for num in recorrido_negra.split(",")]
                                contador_negra=1
                                nueva_coordenada_negra = calcular_coordenadas(lista_estados_negra[contador_negra])
                                if nueva_coordenada_negra not in posicion_blanca:
                                    break
                            turn_step=0
                        if coordenadas_negra in posicion_negra:
                            selection = posicion_negra.index(coordenadas_negra)#Seleccionamos las coordenadas
                            if turn_step == 0:
                                turn_step = 1
                        
                        if turn_step==1 and selection != 100:
                            posicion_negra[0] = nueva_coordenada_negra
                            selection = 100
                            contador_negra += 1
                            coordenadas_negra = nueva_coordenada_negra
                            turn_step=4
                    if turn_step == 2:
                        #print("Blanca")
                        if  nueva_coordenada_blanca in posicion_negra:
                            while(1):
                                #recalculamos ruta
                                print("Colision detectada en recorrido: Recalculamos blanca")
                                ruta_blanca=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza blanca.
                                recorrer_estados_blanca(tablaEstados, ruta_blanca,str(lista_estados_blanca[contador_blanca-1]))
                                recorrido_blanca = seleccionar_recorrido_blanca(str(lista_estados_blanca[contador_blanca-1]))#Este fue el recorrido que se escogio de manera aleatoria para blanca
                                print("La ruta recalculada es: "+recorrido_blanca)
                                lista_estados_blanca = [int(num) for num in recorrido_blanca.split(",")]
                                contador_blanca=1
                                nueva_coordenada_blanca = calcular_coordenadas(lista_estados_blanca[contador_blanca])
                                if nueva_coordenada_blanca not in posicion_negra:
                                    break
                            turn_step=2
                        if coordenadas_blanca in posicion_blanca:
                            selection = posicion_negra.index(coordenadas_negra)#Seleccionamos las coordenadas
                            if turn_step == 2:
                                turn_step = 3
                            
                        if turn_step==3 and selection != 100:
                            posicion_blanca[0] = nueva_coordenada_blanca
                            
                            selection = 100
                            contador_blanca += 1
                            coordenadas_blanca = nueva_coordenada_blanca
                            turn_step=0

        pygame.display.flip()

pygame.quit()


\end{lstlisting}


\section{Main4.py}
El código main solo es el programa principal que nos redireccionara a los archivos .py correspondientes a su asignmación. \newline
\\
\begin{lstlisting}
#Teoria de la computacion
#Buscador de palabras
#Alumno: Connor Urbano Mendoza

import random
import sys
import pygame
import random
import os

pygame.init() #Acceso al paquete pygame
#Ancho
WIDTH = 1000
#Altura
HEIGHT = 700
screen = pygame.display.set_mode((WIDTH,HEIGHT)) #Tamanio de ventana a imprimir
pygame.display.set_caption('Problema del Ajedrez')
font = pygame.font.Font('freesansbold.ttf',20)#Tipo de fuente 1 del juego
big_font= pygame.font.Font('freesansbold.ttf',50)#Tipo de fuente 2 del juego
timer = pygame.time.Clock()#velocidad de actualizacion de nuestro juego a 60 fps
fps=60

#NFA de estados
tablaEstados = {
    '1' : {'R': {'2','5'}, 'N': '6'},
    '2' : {'R': {'5','7'}, 'N': {'1','6','3'}},
    '3' : {'R': {'2','7','4'}, 'N': {'6','8'}},
    '4' : {'R': '7', 'N': {'3','8'}},
    '5' : {'R': {'2','10'}, 'N': {'1','6','9'}},
    '6' : {'R': {'2','5','7','10'}, 'N': {'1','3','9','11'}},
    '7' : {'R': {'2','4','10','12'}, 'N': {'3','6','8','11'}},
    '8' : {'R': {'4','7','12'}, 'N': {'3','11'}},
    '9' : {'R': {'5','10','13'}, 'N': {'6','14'}},
    '10' : {'R': {'5','7','13','15'}, 'N': {'6','9','11','14'}},
    '11' : {'R': {'7','10','12','15'}, 'N': {'6','8','14','16'}},
    '12' : {'R': {'7','15'}, 'N': {'8','11','16'}},
    '13' : {'R': '10', 'N': {'9','14'}},
    '14' : {'R': {'13','10','15'}, 'N': {'9','11'}},
    '15' : {'R': {'10','12'}, 'N': {'11','14','16'}},
    '16' : {'R': {'12','15'}, 'N': '11'}#Estado 16 es el estado Final.
}

#Variables e imagenes del juego
pieza_blanca = ['king']
pieza_negra = ['king']
posicion_blanca =[(235,85)]
posicion_negra =[(683,85)]

#
turn_step = 0
selection= 100
valid_moves_for1 =[]
#Cargar imagenes en juego
rey_blanco = pygame.image.load('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\img\\white_king.png')
rey_blanco = pygame.transform.scale(rey_blanco,(80,80))
rey_negro = pygame.image.load('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\img\\black_king.png')
rey_negro = pygame.transform.scale(rey_negro,(80,80))

imagen_blanca = [rey_blanco]
imagen_negra=[rey_negro]

lista_piezas = ['king']
#ver variables/contador flash


boton_presionado = False

def dibujar_boton():
    boton_width = 150
    boton_height = 45
    boton_x = (WIDTH - boton_width) // 2
    boton_y = (HEIGHT - boton_height - 20)+17

    # Dibujar el botón como un rectángulo en la pantalla
    boton_rect=pygame.Rect(boton_x, boton_y, boton_width, boton_height)
    pygame.draw.rect(screen, (0, 255, 0), (boton_x, boton_y, boton_width, boton_height))
    texto = font.render("Siguiente", True, (0, 0, 0))
    texto_rect = texto.get_rect(center=(boton_x + boton_width // 2, boton_y + boton_height // 2))
    screen.blit(texto, texto_rect)
    return boton_rect
    
#Funcion para dibujar tablero
def dibujar_tablero():
    cuadro_size = 150  # Tamaño de cada cuadro del tablero
    tablero_width = 4 * cuadro_size  # Ancho total del tablero
    tablero_height = 4 * cuadro_size  # Altura total del tablero
    tablero_x = (WIDTH - tablero_width) // 2  # Posición X para centrar el tablero
    tablero_y = (HEIGHT - tablero_height) // 2  # Posición Y para centrar el tablero
    
    numero_color = 'white'  # Color del número de casilla

    font = pygame.font.Font(None, 24)  # Fuente y tamaño del número de casilla

    for i in range(16):  # Iterar 16 veces para un tablero de 4x4
        columna = i % 4
        fila = i // 4
        x = tablero_x + columna * cuadro_size
        y = tablero_y + fila * cuadro_size
        if fila % 2 == 0:
            color = 'black' if columna % 2 == 0 else 'red'
        else:
            color = 'red' if columna % 2 == 0 else 'black'
        pygame.draw.rect(screen, color, [x, y, cuadro_size, cuadro_size])
        pygame.draw.rect(screen, 'white', [x, y, cuadro_size, cuadro_size], 2)  # Agregar borde de color blanco
        numero_texto = font.render(str(i + 1), True, numero_color)  # Crear superficie de texto con el número
        numero_rect = numero_texto.get_rect(center=((x + cuadro_size // 2)-60, y + 20))  # Posición del número en la parte superior del recuadro
        screen.blit(numero_texto, numero_rect)  # Pegar el número en la pantalla

#Funcion para dibujar piezas
def dibujar_piezas():
    index=lista_piezas.index('king')
    if pieza_blanca[0]=='king':     
        screen.blit(imagen_blanca[index],(posicion_blanca[0][0],posicion_blanca[0][1]))
    if pieza_negra[0]=='king':     
        screen.blit(imagen_negra[index],(posicion_negra[0][0],posicion_negra[0][1]))
          
def recorrer_estados_blanca(tabla_estados, cadena,estadoInicial):
    # Función para obtener todos los recorridos posibles blanca
    def obtener_recorridos(estado_actual, simbolos_restantes, recorrido_actual):
        if not simbolos_restantes:
            recorridos2.append(recorrido_actual)
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    # Función para obtener los recorridos válidos hasta el estado final
    def obtener_recorridos_finales(estado_actual, simbolos_restantes, recorrido_actual):
        if estado_actual == '16':
            recorridos_finales.append(recorrido_actual)
            return

        if not simbolos_restantes:
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos_finales(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    
    # Obtener recorridos posibles
    recorridos2 = []
    obtener_recorridos(estadoInicial, cadena, [estadoInicial])
    # Obtener recorridos hasta el estado final
    recorridos_finales = []
    obtener_recorridos_finales(estadoInicial, cadena, [estadoInicial])
    # Guardar los recorridos en archivos de texto
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_blanca.txt', 'w') as archivo_recorridos:
        archivo_recorridos.write('Recorridos posibles:\n')
        for recorrido in recorridos2:
            archivo_recorridos.write(','.join(recorrido) + '\n')

    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_blanca.txt', 'w') as archivo_recorridos_finales:
        for recorrido in recorridos_finales:
            archivo_recorridos_finales.write(','.join(recorrido) + '\n')




def recorrer_estados_negra(tabla_estados, cadena,estadoInicial):
    # Función para obtener todos los recorridos posibles
    def obtener_recorridos(estado_actual, simbolos_restantes, recorrido_actual):
        if not simbolos_restantes:
            recorridos2.append(recorrido_actual)
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    # Función para obtener los recorridos válidos hasta el estado final
    def obtener_recorridos_finales(estado_actual, simbolos_restantes, recorrido_actual):
        if estado_actual == '13':
            recorridos_finales.append(recorrido_actual)
            return

        if not simbolos_restantes:
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos_finales(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    # Obtener recorridos posibles
    recorridos2 = []
    obtener_recorridos(estadoInicial, cadena, [estadoInicial])

    # Obtener recorridos hasta el estado final
    recorridos_finales = []
    obtener_recorridos_finales(estadoInicial, cadena, [estadoInicial])

    # Guardar los recorridos en archivos de texto
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_negra.txt', 'w') as archivo_recorridos:
        archivo_recorridos.write('Recorridos posibles:\n')
        for recorrido in recorridos2:
            archivo_recorridos.write(','.join(recorrido) + '\n')

    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_negra.txt', 'w') as archivo_recorridos_finales:
        for recorrido in recorridos_finales:
            archivo_recorridos_finales.write(','.join(recorrido) + '\n')


def seleccionar_recorrido_blanca(estadoI):
    ruta_archivo = "C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_blanca.txt"
    x=1
    while x==1:
        with open(ruta_archivo, "r+") as archivo:
            if os.path.getsize(ruta_archivo) == 0:
                print("No existen soluciones que lleguen al estado 16 con la condicion actual. Se recalculara una ruta.\n")
                nuevaruta=cadena()
                with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt', 'w') as archivo2:
                    archivo2.write(nuevaruta)
                print("La nueva ruta es: "+nuevaruta)
                recorrer_estados_blanca(tablaEstados, nuevaruta,estadoI)
                print('Se almacenaron las nuevas salidas de los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
            else:
                x=0  
                lineas = archivo.readlines()
                
                # Seleccionar una línea aleatoria
                recorrido_seleccionado = random.choice(lineas)
                
                # Eliminar los espacios en blanco y saltos de línea
                recorrido_seleccionado = recorrido_seleccionado.strip()
            
    return recorrido_seleccionado

def seleccionar_recorrido_negra(estadoI):
    ruta_archivo = "C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_negra.txt"
    x=1
    while x==1:
        with open(ruta_archivo, "r+") as archivo:
            if os.path.getsize(ruta_archivo) == 0:
                print("No existen soluciones que lleguen al estado 13 con la condicion actual. Se recalculara una ruta.\n")
                nuevaruta=cadena()
                with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_negra.txt', 'w') as archivo2:
                    archivo2.write(nuevaruta)
                print("La nueva ruta es: "+nuevaruta)
                recorrer_estados_negra(tablaEstados, nuevaruta,estadoI)
                print('Se almacenaron las nuevas salidas de los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
            else:#16
                x=0  
                lineas = archivo.readlines()
                
                # Seleccionar una línea aleatoria
                recorrido_seleccionado = random.choice(lineas)
                
                # Eliminar los espacios en blanco y saltos de línea
                recorrido_seleccionado = recorrido_seleccionado.strip()
            
    return recorrido_seleccionado

def cadenaRandom(numero): #Genera un string de forma random 
    auxiliar = '' #Variable auxiliar
    for i in range(numero):
        x = random.randint(1, 2) #Función para generar un resultado random de una lista
        if x % 2 == 0:
            auxiliar = auxiliar + "R"
        else:
            auxiliar = auxiliar + "N"
    return auxiliar

def cadena():
    numero = random.randint(4,10)
    print('\nTamanio de cadena escogido aleatoriamente ['+str(numero)+']\nTambien se generaran las transiciones R y N aleatoriamente.\n')
    cad = cadenaRandom(numero) #Se genera de forma aleatoria del 1-10
    print('\nLa cadena o ruta a seguir escogida aleatoriamente sera: '+cad+'\n')
    return cad

def cadena_manual():
    while 1:
        ruta = input("Ingrese la cadena usando las transiciones R y N.\n").upper()
        if len(ruta) > 10:
            print("\nNo es posible introducir más de 10 caracteres en la cadena de recorrido para animacion. Desea seguir de igual forma?(Ya no se animara, se procedera al arbol)")
            respuesta = int(input("1. Si.\n2. No.\n"))
            if respuesta == 1:
                break
            else:
                pass
        else:
            break
    print('\nTamanio de cadena escogido ['+str(len(ruta))+'].')
    print('\nLa cadena o ruta a seguir escogida sera: '+ruta+'\n')
    return ruta

def calcular_coordenadas(estado):
    cuadro_size = 150  # Tamaño de cada cuadro del tablero
    tablero_width = 4 * cuadro_size  # Ancho total del tablero
    tablero_height = 4 * cuadro_size  # Altura total del tablero
    tablero_x = (WIDTH - tablero_width) // 2  # Posición X para centrar el tablero
    tablero_y = (HEIGHT - tablero_height) // 2  # Posición Y para centrar el tablero
    fila = (estado - 1) // 4  # Calcular la fila del estado
    columna = (estado - 1) % 4  # Calcular la columna del estado
    x = tablero_x + columna * cuadro_size  # Calcular la coordenada X del estado
    y = tablero_y + fila * cuadro_size  # Calcular la coordenada Y del estado
    return ((x+33), y+33)  # Devolver las coordenadas como una tupla



#def dibujar_movimientos():

#Main del ciclo del juego 4
# Verificar el número aleatorio y determinar si se sacan piezas blancas o negras
numero_aleatorio = random.randint(1, 2)
# Escogemos aleatoriamente que pieza le toca jugar al manual
juegomanual = random.randint(1, 2)

#Guardamos rutas para arbol.
if juegomanual == 1:
    print("Te toca jugar con blancas.")
    print("\n--PARA CADENA BLANCA--")
    ruta_blanca=cadena_manual()
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt', 'w') as archivo:
        archivo.write(ruta_blanca)
    if len(ruta_blanca)> 10:
        sys.exit(3)
    recorrer_estados_blanca(tablaEstados, ruta_blanca,"1")
    print("\n--PARA CADENA NEGRA--")
    ruta_negra=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza negra.    
    recorrer_estados_negra(tablaEstados, ruta_negra,"4")
    
elif juegomanual == 2:
    print("Te toca jugar con negras.")
    print("\n--PARA CADENA NEGRA--")
    ruta_negra=cadena_manual()
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_negra.txt', 'w') as archivo:
        archivo.write(ruta_negra)
    if len(ruta_negra)> 10:
        sys.exit(3)
    recorrer_estados_negra(tablaEstados, ruta_negra,"4")
    print("\n--PARA CADENA BLANCA--")
    ruta_blanca=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza blanca.
    recorrer_estados_blanca(tablaEstados, ruta_blanca,"1")


print('\nEn este punto el programa almaceno en la salidas los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
recorrido_blanca = seleccionar_recorrido_blanca("1")#Este fue el recorrido que se escogio de manera aleatoria para blanca
recorrido_negra = seleccionar_recorrido_negra("4")#Este fue el recorrido que se escogio de manera aleatoria para negra

with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt', 'w') as archivo:
    archivo.write(ruta_blanca)
with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_negra.txt', 'w') as archivo:
    archivo.write(ruta_negra)

print("\nRecorrido seleccionado para blanca:", recorrido_blanca)
print("\nRecorrido seleccionado para negra:", recorrido_negra)
lista_estados_blanca = [int(num) for num in recorrido_blanca.split(",")]
lista_estados_negra = [int(num) for num in recorrido_negra.split(",")]


coordenadas_blanca=(235,85)
nueva_coordenada_blanca=(0,0)
coordenadas_negra=(683,85)
nueva_coordenada_negra=(0,0)
run=True
contador_blanca=1
contador_negra=1

if numero_aleatorio == 1:
    print("\nSacan piezas blancas.")
    # Sacan piezas blancas
    while run:
        timer.tick(fps)
        screen.fill('dark gray')
        dibujar_tablero()
        dibujar_piezas()
        boton_rect = dibujar_boton()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                mouse_pos = pygame.mouse.get_pos()
                if boton_rect.collidepoint(mouse_pos):  # Verificar si se hizo clic en el botón
                    if turn_step ==4:
                        turn_step=2
                    nueva_coordenada_blanca = calcular_coordenadas(lista_estados_blanca[contador_blanca])
                    nueva_coordenada_negra = calcular_coordenadas(lista_estados_negra[contador_negra])
                    
                    if turn_step <= 1:
                        #print("Blanca")
                        if  nueva_coordenada_blanca in posicion_negra:
                            while(1):#Ciclo while, donde para salir la siguiente coordenada no pueda ser la de la colision
                                #recalculamos ruta
                                print("Colision detectada en recorrido: Recalculamos blanca")
                                ruta_blanca=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza blanca.
                                recorrer_estados_blanca(tablaEstados, ruta_blanca,str(lista_estados_blanca[contador_blanca-1]))
                                recorrido_blanca = seleccionar_recorrido_blanca(str(lista_estados_blanca[contador_blanca-1]))#Este fue el recorrido que se escogio de manera aleatoria para blanca
                                print("La ruta recalculada es: "+recorrido_blanca)
                                lista_estados_blanca = [int(num) for num in recorrido_blanca.split(",")]
                                contador_blanca=1
                                nueva_coordenada_blanca = calcular_coordenadas(lista_estados_blanca[contador_blanca])
                                if nueva_coordenada_blanca not in posicion_negra:
                                    break
                            turn_step=0
                        if coordenadas_blanca in posicion_blanca:
                            selection = posicion_blanca.index(coordenadas_blanca)
                            if turn_step == 0:
                                turn_step = 1
                        
                        if turn_step==1 and selection != 100:
                            posicion_blanca[0] = nueva_coordenada_blanca
                            
                            selection = 100
                            contador_blanca += 1
                            coordenadas_blanca = nueva_coordenada_blanca
                            turn_step=4
                    if turn_step == 2:
                        #print("Negra")
                        if  nueva_coordenada_negra in posicion_blanca:
                            while(1):
                                #recalculamos ruta
                                print("Colision detectada en recorrido: Recalculamos negra.")
                                ruta_negra=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza negra.
                                recorrer_estados_negra(tablaEstados, ruta_negra,str(lista_estados_negra[contador_negra-1]))
                                recorrido_negra = seleccionar_recorrido_negra(str(lista_estados_negra[contador_negra-1]))#Este fue el recorrido que se escogio de manera aleatoria para blanca
                                print("La ruta recalculada es: "+recorrido_negra)
                                lista_estados_negra = [int(num) for num in recorrido_negra.split(",")]
                                contador_negra=1
                                nueva_coordenada_negra = calcular_coordenadas(lista_estados_negra[contador_negra])
                                if nueva_coordenada_negra not in posicion_blanca:
                                    break
                            turn_step=2
                        if coordenadas_negra in posicion_negra:
                            selection = posicion_negra.index(coordenadas_negra)#Seleccionamos las coordenadas
                            if turn_step == 2:
                                turn_step = 3
                            
                        if turn_step==3 and selection != 100:
                            posicion_negra[0] = nueva_coordenada_negra
                            selection = 100
                            contador_negra += 1
                            coordenadas_negra = nueva_coordenada_negra
                            turn_step=0

        pygame.display.flip()
else:
    # Sacan piezas negras
    print("\nSacan piezas negras.")
    while run:
        timer.tick(fps)
        screen.fill('dark gray')
        dibujar_tablero()
        dibujar_piezas()
        boton_rect = dibujar_boton()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                mouse_pos = pygame.mouse.get_pos()
                if boton_rect.collidepoint(mouse_pos):  # Verificar si se hizo clic en el botón
                    if turn_step ==4:
                        turn_step=2
                    nueva_coordenada_blanca = calcular_coordenadas(lista_estados_blanca[contador_blanca])
                    nueva_coordenada_negra = calcular_coordenadas(lista_estados_negra[contador_negra])
                    
                    if turn_step <= 1:
                        #print("Negra")
                        if  nueva_coordenada_negra in posicion_blanca:
                            while(1):#Ciclo while, donde para salir la siguiente coordenada no pueda ser la de la colision
                                #recalculamos ruta
                                print("Colision detectada en recorrido: Recalculamos negra.")
                                ruta_negra=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza negra.
                                recorrer_estados_negra(tablaEstados, ruta_negra,str(lista_estados_negra[contador_negra-1]))
                                recorrido_negra = seleccionar_recorrido_negra(str(lista_estados_negra[contador_negra-1]))#Este fue el recorrido que se escogio de manera aleatoria para blanca
                                print("La ruta recalculada es: "+recorrido_negra)
                                lista_estados_negra = [int(num) for num in recorrido_negra.split(",")]
                                contador_negra=1
                                nueva_coordenada_negra = calcular_coordenadas(lista_estados_negra[contador_negra])
                                if nueva_coordenada_negra not in posicion_blanca:
                                    break
                            turn_step=0
                        if coordenadas_negra in posicion_negra:
                            selection = posicion_negra.index(coordenadas_negra)#Seleccionamos las coordenadas
                            if turn_step == 0:
                                turn_step = 1
                        
                        if turn_step==1 and selection != 100:
                            posicion_negra[0] = nueva_coordenada_negra
                            selection = 100
                            contador_negra += 1
                            coordenadas_negra = nueva_coordenada_negra
                            turn_step=4
                    if turn_step == 2:
                        #print("Blanca")
                        if  nueva_coordenada_blanca in posicion_negra:
                            while(1):
                                #recalculamos ruta
                                print("Colision detectada en recorrido: Recalculamos blanca")
                                ruta_blanca=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza blanca.
                                recorrer_estados_blanca(tablaEstados, ruta_blanca,str(lista_estados_blanca[contador_blanca-1]))
                                recorrido_blanca = seleccionar_recorrido_blanca(str(lista_estados_blanca[contador_blanca-1]))#Este fue el recorrido que se escogio de manera aleatoria para blanca
                                print("La ruta recalculada es: "+recorrido_blanca)
                                lista_estados_blanca = [int(num) for num in recorrido_blanca.split(",")]
                                contador_blanca=1
                                nueva_coordenada_blanca = calcular_coordenadas(lista_estados_blanca[contador_blanca])
                                if nueva_coordenada_blanca not in posicion_negra:
                                    break
                            turn_step=2
                        if coordenadas_blanca in posicion_blanca:
                            selection = posicion_negra.index(coordenadas_negra)#Seleccionamos las coordenadas
                            if turn_step == 2:
                                turn_step = 3
                            
                        if turn_step==3 and selection != 100:
                            posicion_blanca[0] = nueva_coordenada_blanca
                            
                            selection = 100
                            contador_blanca += 1
                            coordenadas_blanca = nueva_coordenada_blanca
                            turn_step=0

        pygame.display.flip()

pygame.quit()


\end{lstlisting}


\section{Main5.py}
El código main solo es el programa principal que nos redireccionara a los archivos .py correspondientes a su asignmación. \newline
\\
\begin{lstlisting}
#Teoria de la computacion
#Buscador de palabras
#Alumno: Connor Urbano Mendoza

import random
import sys
import pygame
import random
import os

pygame.init() #Acceso al paquete pygame
#Ancho
WIDTH = 1000
#Altura
HEIGHT = 700
screen = pygame.display.set_mode((WIDTH,HEIGHT)) #Tamanio de ventana a imprimir
pygame.display.set_caption('Problema del Ajedrez')
font = pygame.font.Font('freesansbold.ttf',20)#Tipo de fuente 1 del juego
big_font= pygame.font.Font('freesansbold.ttf',50)#Tipo de fuente 2 del juego
timer = pygame.time.Clock()#velocidad de actualizacion de nuestro juego a 60 fps
fps=60

#NFA de estados
tablaEstados = {
    '1' : {'R': {'2','5'}, 'N': '6'},
    '2' : {'R': {'5','7'}, 'N': {'1','6','3'}},
    '3' : {'R': {'2','7','4'}, 'N': {'6','8'}},
    '4' : {'R': '7', 'N': {'3','8'}},
    '5' : {'R': {'2','10'}, 'N': {'1','6','9'}},
    '6' : {'R': {'2','5','7','10'}, 'N': {'1','3','9','11'}},
    '7' : {'R': {'2','4','10','12'}, 'N': {'3','6','8','11'}},
    '8' : {'R': {'4','7','12'}, 'N': {'3','11'}},
    '9' : {'R': {'5','10','13'}, 'N': {'6','14'}},
    '10' : {'R': {'5','7','13','15'}, 'N': {'6','9','11','14'}},
    '11' : {'R': {'7','10','12','15'}, 'N': {'6','8','14','16'}},
    '12' : {'R': {'7','15'}, 'N': {'8','11','16'}},
    '13' : {'R': '10', 'N': {'9','14'}},
    '14' : {'R': {'13','10','15'}, 'N': {'9','11'}},
    '15' : {'R': {'10','12'}, 'N': {'11','14','16'}},
    '16' : {'R': {'12','15'}, 'N': '11'}#Estado 16 es el estado Final.
}

#Variables e imagenes del juego
pieza_blanca = ['king']
pieza_negra = ['king']
posicion_blanca =[(235,85)]
posicion_negra =[(683,85)]

#
turn_step = 0
selection= 100
valid_moves_for1 =[]
#Cargar imagenes en juego
rey_blanco = pygame.image.load('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\img\\white_king.png')
rey_blanco = pygame.transform.scale(rey_blanco,(80,80))
rey_negro = pygame.image.load('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\img\\black_king.png')
rey_negro = pygame.transform.scale(rey_negro,(80,80))

imagen_blanca = [rey_blanco]
imagen_negra=[rey_negro]

lista_piezas = ['king']
#ver variables/contador flash


boton_presionado = False

def dibujar_boton():
    boton_width = 150
    boton_height = 45
    boton_x = (WIDTH - boton_width) // 2
    boton_y = (HEIGHT - boton_height - 20)+17

    # Dibujar el botón como un rectángulo en la pantalla
    boton_rect=pygame.Rect(boton_x, boton_y, boton_width, boton_height)
    pygame.draw.rect(screen, (0, 255, 0), (boton_x, boton_y, boton_width, boton_height))
    texto = font.render("Siguiente", True, (0, 0, 0))
    texto_rect = texto.get_rect(center=(boton_x + boton_width // 2, boton_y + boton_height // 2))
    screen.blit(texto, texto_rect)
    return boton_rect
    
#Funcion para dibujar tablero
def dibujar_tablero():
    cuadro_size = 150  # Tamaño de cada cuadro del tablero
    tablero_width = 4 * cuadro_size  # Ancho total del tablero
    tablero_height = 4 * cuadro_size  # Altura total del tablero
    tablero_x = (WIDTH - tablero_width) // 2  # Posición X para centrar el tablero
    tablero_y = (HEIGHT - tablero_height) // 2  # Posición Y para centrar el tablero
    
    numero_color = 'white'  # Color del número de casilla

    font = pygame.font.Font(None, 24)  # Fuente y tamaño del número de casilla

    for i in range(16):  # Iterar 16 veces para un tablero de 4x4
        columna = i % 4
        fila = i // 4
        x = tablero_x + columna * cuadro_size
        y = tablero_y + fila * cuadro_size
        if fila % 2 == 0:
            color = 'black' if columna % 2 == 0 else 'red'
        else:
            color = 'red' if columna % 2 == 0 else 'black'
        pygame.draw.rect(screen, color, [x, y, cuadro_size, cuadro_size])
        pygame.draw.rect(screen, 'white', [x, y, cuadro_size, cuadro_size], 2)  # Agregar borde de color blanco
        numero_texto = font.render(str(i + 1), True, numero_color)  # Crear superficie de texto con el número
        numero_rect = numero_texto.get_rect(center=((x + cuadro_size // 2)-60, y + 20))  # Posición del número en la parte superior del recuadro
        screen.blit(numero_texto, numero_rect)  # Pegar el número en la pantalla

#Funcion para dibujar piezas
def dibujar_piezas():
    index=lista_piezas.index('king')
    if pieza_blanca[0]=='king':     
        screen.blit(imagen_blanca[index],(posicion_blanca[0][0],posicion_blanca[0][1]))
    if pieza_negra[0]=='king':     
        screen.blit(imagen_negra[index],(posicion_negra[0][0],posicion_negra[0][1]))
          
def recorrer_estados_blanca(tabla_estados, cadena,estadoInicial):
    # Función para obtener todos los recorridos posibles blanca
    def obtener_recorridos(estado_actual, simbolos_restantes, recorrido_actual):
        if not simbolos_restantes:
            recorridos2.append(recorrido_actual)
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    # Función para obtener los recorridos válidos hasta el estado final
    def obtener_recorridos_finales(estado_actual, simbolos_restantes, recorrido_actual):
        if estado_actual == '16':
            recorridos_finales.append(recorrido_actual)
            return

        if not simbolos_restantes:
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos_finales(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    
    # Obtener recorridos posibles
    recorridos2 = []
    obtener_recorridos(estadoInicial, cadena, [estadoInicial])
    # Obtener recorridos hasta el estado final
    recorridos_finales = []
    obtener_recorridos_finales(estadoInicial, cadena, [estadoInicial])
    # Guardar los recorridos en archivos de texto
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_blanca.txt', 'w') as archivo_recorridos:
        archivo_recorridos.write('Recorridos posibles:\n')
        for recorrido in recorridos2:
            archivo_recorridos.write(','.join(recorrido) + '\n')

    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_blanca.txt', 'w') as archivo_recorridos_finales:
        for recorrido in recorridos_finales:
            archivo_recorridos_finales.write(','.join(recorrido) + '\n')




def recorrer_estados_negra(tabla_estados, cadena,estadoInicial):
    # Función para obtener todos los recorridos posibles
    def obtener_recorridos(estado_actual, simbolos_restantes, recorrido_actual):
        if not simbolos_restantes:
            recorridos2.append(recorrido_actual)
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    # Función para obtener los recorridos válidos hasta el estado final
    def obtener_recorridos_finales(estado_actual, simbolos_restantes, recorrido_actual):
        if estado_actual == '13':
            recorridos_finales.append(recorrido_actual)
            return

        if not simbolos_restantes:
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos_finales(estado_siguiente, simbolos_restantes[1:], recorrido_actual + [estado_siguiente])

    # Obtener recorridos posibles
    recorridos2 = []
    obtener_recorridos(estadoInicial, cadena, [estadoInicial])

    # Obtener recorridos hasta el estado final
    recorridos_finales = []
    obtener_recorridos_finales(estadoInicial, cadena, [estadoInicial])

    # Guardar los recorridos en archivos de texto
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_negra.txt', 'w') as archivo_recorridos:
        archivo_recorridos.write('Recorridos posibles:\n')
        for recorrido in recorridos2:
            archivo_recorridos.write(','.join(recorrido) + '\n')

    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_negra.txt', 'w') as archivo_recorridos_finales:
        for recorrido in recorridos_finales:
            archivo_recorridos_finales.write(','.join(recorrido) + '\n')


def seleccionar_recorrido_blanca(estadoI):
    ruta_archivo = "C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_blanca.txt"
    x=1
    while x==1:
        with open(ruta_archivo, "r+") as archivo:
            if os.path.getsize(ruta_archivo) == 0:
                print("No existen soluciones que lleguen al estado 16 con la condicion actual. Se recalculara una ruta.\n")
                nuevaruta=cadena()
                with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt', 'w') as archivo2:
                    archivo2.write(nuevaruta)
                print("La nueva ruta es: "+nuevaruta)
                recorrer_estados_blanca(tablaEstados, nuevaruta,estadoI)
                print('Se almacenaron las nuevas salidas de los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
            else:
                x=0  
                lineas = archivo.readlines()
                
                # Seleccionar una línea aleatoria
                recorrido_seleccionado = random.choice(lineas)
                
                # Eliminar los espacios en blanco y saltos de línea
                recorrido_seleccionado = recorrido_seleccionado.strip()
            
    return recorrido_seleccionado

def seleccionar_recorrido_negra(estadoI):
    ruta_archivo = "C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_finales_negra.txt"
    x=1
    while x==1:
        with open(ruta_archivo, "r+") as archivo:
            if os.path.getsize(ruta_archivo) == 0:
                print("No existen soluciones que lleguen al estado 13 con la condicion actual. Se recalculara una ruta.\n")
                nuevaruta=cadena()
                with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_negra.txt', 'w') as archivo2:
                    archivo2.write(nuevaruta)
                print("La nueva ruta es: "+nuevaruta)
                recorrer_estados_negra(tablaEstados, nuevaruta,estadoI)
                print('Se almacenaron las nuevas salidas de los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
            else:#16
                x=0  
                lineas = archivo.readlines()
                
                # Seleccionar una línea aleatoria
                recorrido_seleccionado = random.choice(lineas)
                
                # Eliminar los espacios en blanco y saltos de línea
                recorrido_seleccionado = recorrido_seleccionado.strip()
            
    return recorrido_seleccionado

def cadenaRandom(numero): #Genera un string de forma random 
    auxiliar = '' #Variable auxiliar
    for i in range(numero):
        x = random.randint(1, 2) #Función para generar un resultado random de una lista
        if x % 2 == 0:
            auxiliar = auxiliar + "R"
        else:
            auxiliar = auxiliar + "N"
    return auxiliar

def cadena():
    numero = random.randint(4,10)
    print('\nTamanio de cadena escogido aleatoriamente ['+str(numero)+']\nTambien se generaran las transiciones R y N aleatoriamente.\n')
    cad = cadenaRandom(numero) #Se genera de forma aleatoria del 1-10
    print('\nLa cadena o ruta a seguir escogida aleatoriamente sera: '+cad+'\n')
    return cad

def cadena_manual():
    while 1:
        ruta = input("Ingrese la cadena usando las transiciones R y N.\n").upper()
        if len(ruta) > 10:
            print("\nNo es posible introducir más de 10 caracteres en la cadena de recorrido para animacion. Desea seguir de igual forma?(Ya no se animara, se procedera al arbol)")
            respuesta = int(input("1. Si.\n2. No.\n"))
            if respuesta == 1:
                break
            else:
                pass
        else:
            break
    print('\nTamanio de cadena escogido ['+str(len(ruta))+'].')
    print('\nLa cadena o ruta a seguir escogida sera: '+ruta+'\n')
    return ruta

def calcular_coordenadas(estado):
    cuadro_size = 150  # Tamaño de cada cuadro del tablero
    tablero_width = 4 * cuadro_size  # Ancho total del tablero
    tablero_height = 4 * cuadro_size  # Altura total del tablero
    tablero_x = (WIDTH - tablero_width) // 2  # Posición X para centrar el tablero
    tablero_y = (HEIGHT - tablero_height) // 2  # Posición Y para centrar el tablero
    fila = (estado - 1) // 4  # Calcular la fila del estado
    columna = (estado - 1) % 4  # Calcular la columna del estado
    x = tablero_x + columna * cuadro_size  # Calcular la coordenada X del estado
    y = tablero_y + fila * cuadro_size  # Calcular la coordenada Y del estado
    return ((x+33), y+33)  # Devolver las coordenadas como una tupla



#def dibujar_movimientos():

#Main del ciclo del juego 5

# Verificar el número aleatorio y determinar si se sacan piezas blancas o negras
numero_aleatorio = random.randint(1, 2)
# Escogemos quien sera pieza negra y quien la blanca
print('Establezcan presencialmente quien sera la pieza blanca o negra.')

while 1:
    bandera_ruta=0#Bandera para arbol de mas de 10.
    #Guardamos rutas para arbol.
    print("\n--PARA PIEZAS BLANCA--")
    ruta_blanca=cadena_manual()
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt', 'w') as archivo:
        archivo.write(ruta_blanca)
    if len(ruta_blanca)> 10:
        bandera_ruta=1
    else:
        bandera_ruta=0
        recorrer_estados_blanca(tablaEstados, ruta_blanca,"1")

    print("\n--PARA CADENA NEGRA--")
    ruta_negra=cadena_manual()
    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_negra.txt', 'w') as archivo:
        archivo.write(ruta_negra)
    if len(ruta_negra)> 10:
        if bandera_ruta==1:
            print("Ambas rutas son mayores a 10, se procede al arbol sin llegar a la animacion.")
            sys.exit(3)
        else:
            print("La ruta blanca es menor a 10, y la negra mayor a 10, por lo que se procede a preguntar de nuevo las rutas.")
            input("Presione ENTER para continuar")
            os.system('cls' if os.name == 'nt' else 'clear')
    else:
        if bandera_ruta==0:
            #ambas rutas menores a 10, se animan.
            recorrer_estados_negra(tablaEstados, ruta_negra,"4")
            break
        else:
            print("La ruta negra es menor a 10, y la blanca mayor a 10, por lo que se procede a preguntar de nuevo las rutas.")
            input("Presione ENTER para continuar")
            os.system('cls' if os.name == 'nt' else 'clear')


print('\nEn este punto el programa almaceno en la salidas los recorridos posibles y los recorridos exitosos en la carpeta output.\n')
recorrido_blanca = seleccionar_recorrido_blanca("1")#Este fue el recorrido que se escogio de manera aleatoria para blanca
recorrido_negra = seleccionar_recorrido_negra("4")#Este fue el recorrido que se escogio de manera aleatoria para negra

with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt', 'w') as archivo:
    archivo.write(ruta_blanca)
with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_negra.txt', 'w') as archivo:
    archivo.write(ruta_negra)

print("\nRecorrido seleccionado para blanca:", recorrido_blanca)
print("\nRecorrido seleccionado para negra:", recorrido_negra)
lista_estados_blanca = [int(num) for num in recorrido_blanca.split(",")]
lista_estados_negra = [int(num) for num in recorrido_negra.split(",")]


coordenadas_blanca=(235,85)
nueva_coordenada_blanca=(0,0)
coordenadas_negra=(683,85)
nueva_coordenada_negra=(0,0)
run=True
contador_blanca=1
contador_negra=1

if numero_aleatorio == 1:
    print("\nSacan piezas blancas.")
    # Sacan piezas blancas
    while run:
        timer.tick(fps)
        screen.fill('dark gray')
        dibujar_tablero()
        dibujar_piezas()
        boton_rect = dibujar_boton()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                mouse_pos = pygame.mouse.get_pos()
                if boton_rect.collidepoint(mouse_pos):  # Verificar si se hizo clic en el botón
                    if turn_step ==4:
                        turn_step=2
                    nueva_coordenada_blanca = calcular_coordenadas(lista_estados_blanca[contador_blanca])
                    nueva_coordenada_negra = calcular_coordenadas(lista_estados_negra[contador_negra])
                    
                    if turn_step <= 1:
                        #print("Blanca")
                        if  nueva_coordenada_blanca in posicion_negra:
                            while(1):#Ciclo while, donde para salir la siguiente coordenada no pueda ser la de la colision
                                #recalculamos ruta
                                print("Colision detectada en recorrido: Recalculamos blanca")
                                ruta_blanca=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza blanca.
                                recorrer_estados_blanca(tablaEstados, ruta_blanca,str(lista_estados_blanca[contador_blanca-1]))
                                recorrido_blanca = seleccionar_recorrido_blanca(str(lista_estados_blanca[contador_blanca-1]))#Este fue el recorrido que se escogio de manera aleatoria para blanca
                                print("La ruta recalculada es: "+recorrido_blanca)
                                lista_estados_blanca = [int(num) for num in recorrido_blanca.split(",")]
                                contador_blanca=1
                                nueva_coordenada_blanca = calcular_coordenadas(lista_estados_blanca[contador_blanca])
                                if nueva_coordenada_blanca not in posicion_negra:
                                    break
                            turn_step=0
                        if coordenadas_blanca in posicion_blanca:
                            selection = posicion_blanca.index(coordenadas_blanca)
                            if turn_step == 0:
                                turn_step = 1
                        
                        if turn_step==1 and selection != 100:
                            posicion_blanca[0] = nueva_coordenada_blanca
                            
                            selection = 100
                            contador_blanca += 1
                            coordenadas_blanca = nueva_coordenada_blanca
                            turn_step=4
                    if turn_step == 2:
                        #print("Negra")
                        if  nueva_coordenada_negra in posicion_blanca:
                            while(1):
                                #recalculamos ruta
                                print("Colision detectada en recorrido: Recalculamos negra.")
                                ruta_negra=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza negra.
                                recorrer_estados_negra(tablaEstados, ruta_negra,str(lista_estados_negra[contador_negra-1]))
                                recorrido_negra = seleccionar_recorrido_negra(str(lista_estados_negra[contador_negra-1]))#Este fue el recorrido que se escogio de manera aleatoria para blanca
                                print("La ruta recalculada es: "+recorrido_negra)
                                lista_estados_negra = [int(num) for num in recorrido_negra.split(",")]
                                contador_negra=1
                                nueva_coordenada_negra = calcular_coordenadas(lista_estados_negra[contador_negra])
                                if nueva_coordenada_negra not in posicion_blanca:
                                    break
                            turn_step=2
                        if coordenadas_negra in posicion_negra:
                            selection = posicion_negra.index(coordenadas_negra)#Seleccionamos las coordenadas
                            if turn_step == 2:
                                turn_step = 3
                            
                        if turn_step==3 and selection != 100:
                            posicion_negra[0] = nueva_coordenada_negra
                            selection = 100
                            contador_negra += 1
                            coordenadas_negra = nueva_coordenada_negra
                            turn_step=0

        pygame.display.flip()
else:
    # Sacan piezas negras
    print("\nSacan piezas negras.")
    while run:
        timer.tick(fps)
        screen.fill('dark gray')
        dibujar_tablero()
        dibujar_piezas()
        boton_rect = dibujar_boton()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                mouse_pos = pygame.mouse.get_pos()
                if boton_rect.collidepoint(mouse_pos):  # Verificar si se hizo clic en el botón
                    if turn_step ==4:
                        turn_step=2
                    nueva_coordenada_blanca = calcular_coordenadas(lista_estados_blanca[contador_blanca])
                    nueva_coordenada_negra = calcular_coordenadas(lista_estados_negra[contador_negra])
                    
                    if turn_step <= 1:
                        #print("Negra")
                        if  nueva_coordenada_negra in posicion_blanca:
                            while(1):#Ciclo while, donde para salir la siguiente coordenada no pueda ser la de la colision
                                #recalculamos ruta
                                print("Colision detectada en recorrido: Recalculamos negra.")
                                ruta_negra=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza negra.
                                recorrer_estados_negra(tablaEstados, ruta_negra,str(lista_estados_negra[contador_negra-1]))
                                recorrido_negra = seleccionar_recorrido_negra(str(lista_estados_negra[contador_negra-1]))#Este fue el recorrido que se escogio de manera aleatoria para blanca
                                print("La ruta recalculada es: "+recorrido_negra)
                                lista_estados_negra = [int(num) for num in recorrido_negra.split(",")]
                                contador_negra=1
                                nueva_coordenada_negra = calcular_coordenadas(lista_estados_negra[contador_negra])
                                if nueva_coordenada_negra not in posicion_blanca:
                                    break
                            turn_step=0
                        if coordenadas_negra in posicion_negra:
                            selection = posicion_negra.index(coordenadas_negra)#Seleccionamos las coordenadas
                            if turn_step == 0:
                                turn_step = 1
                        
                        if turn_step==1 and selection != 100:
                            posicion_negra[0] = nueva_coordenada_negra
                            selection = 100
                            contador_negra += 1
                            coordenadas_negra = nueva_coordenada_negra
                            turn_step=4
                    if turn_step == 2:
                        #print("Blanca")
                        if  nueva_coordenada_blanca in posicion_negra:
                            while(1):
                                #recalculamos ruta
                                print("Colision detectada en recorrido: Recalculamos blanca")
                                ruta_blanca=cadena()#Solicitamos la cadena generada aleatoriamente. Para pieza blanca.
                                recorrer_estados_blanca(tablaEstados, ruta_blanca,str(lista_estados_blanca[contador_blanca-1]))
                                recorrido_blanca = seleccionar_recorrido_blanca(str(lista_estados_blanca[contador_blanca-1]))#Este fue el recorrido que se escogio de manera aleatoria para blanca
                                print("La ruta recalculada es: "+recorrido_blanca)
                                lista_estados_blanca = [int(num) for num in recorrido_blanca.split(",")]
                                contador_blanca=1
                                nueva_coordenada_blanca = calcular_coordenadas(lista_estados_blanca[contador_blanca])
                                if nueva_coordenada_blanca not in posicion_negra:
                                    break
                            turn_step=2
                        if coordenadas_blanca in posicion_blanca:
                            selection = posicion_negra.index(coordenadas_negra)#Seleccionamos las coordenadas
                            if turn_step == 2:
                                turn_step = 3
                            
                        if turn_step==3 and selection != 100:
                            posicion_blanca[0] = nueva_coordenada_blanca
                            
                            selection = 100
                            contador_blanca += 1
                            coordenadas_blanca = nueva_coordenada_blanca
                            turn_step=0

        pygame.display.flip()

pygame.quit()


\end{lstlisting}


\section{graficador.py}
El código main solo es el programa principal que nos redireccionara a los archivos .py correspondientes a su asignmación. \newline
\\
\begin{lstlisting}
import sys
from graphviz import Digraph

# Leer el argumento pasado desde el programa principal
x=0
if len(sys.argv) > 1:
    x=((sys.argv[1]))
    #print((x))
else:
    print("No se pasó ningún argumento.")
    sys.exit(1)

def recorrer_estados_blanca(tabla_estados, cadena):
    def obtener_recorridos(estado_actual, simbolos_restantes, recorrido_actual, archivo_recorridos):
        if not simbolos_restantes:
            archivo_recorridos.write(','.join(recorrido_actual) + '\n')
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos(
                    estado_siguiente,
                    simbolos_restantes[1:],
                    recorrido_actual + [estado_siguiente],
                    archivo_recorridos
                )

    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_blanca.txt', 'w') as archivo_recorridos:
        obtener_recorridos('1', cadena, ['1'], archivo_recorridos)

def recorrer_estados_negra(tabla_estados, cadena):
    def obtener_recorridos2(estado_actual, simbolos_restantes, recorrido_actual, archivo_recorridos):
        if not simbolos_restantes:
            archivo_recorridos.write(','.join(recorrido_actual) + '\n')
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos2(
                    estado_siguiente,
                    simbolos_restantes[1:],
                    recorrido_actual + [estado_siguiente],
                    archivo_recorridos
                )

    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_negra.txt', 'w') as archivo_recorridos:
        obtener_recorridos2('4', cadena, ['4'], archivo_recorridos)

def agregar_recorrido_al_grafo(grafo, transicion, transiciones_posibles):
    estados = transicion.split(',')

    for i in range(len(estados) - 1):
        origen = estados[i]
        destino = estados[i+1]
        if [origen, destino] not in transiciones_posibles:
            # Obtener el símbolo asociado a la transición
            if origen in tablaEstados and 'R' in tablaEstados[origen] and destino in tablaEstados[origen]['R']:
                simbolo = 'R'
            elif origen in tablaEstados and 'N' in tablaEstados[origen] and destino in tablaEstados[origen]['N']:
                simbolo = 'N'
            else:
                simbolo = ''
            #Parte donde se calcula el simbolo asociado a la trancicion o arista/flecha, recuerda que puede ser N o R dependiendo de la tabla de estados.
            grafo.edge(origen, destino,arrowhead="normal",label=simbolo)  # Utilizamos el método 'edge' para agregar una arista
            transiciones_posibles.append([origen, destino],)
    

def generar_arbol_recorridos(tabla_estados, ruta_evaluar, archivo_recorridos, archivo_salida):
    grafo = Digraph('G', filename='arbol.gv')
    grafo.attr(rankdir='LR', size='8,5')
    grafo.graph_attr['label'] = ruta_evaluar  # Agregar título al gráfico
    with open(archivo_recorridos, 'r') as file:
        for linea in file:
            recorrido = linea.strip()
            agregar_recorrido_al_grafo(grafo, recorrido,transiciones_posibles)
        
    archivo_salida_pdf = archivo_salida.replace('.dot', '.pdf')
    grafo.render(archivo_salida_pdf, view=True)

tablaEstados = {
    '1': {'R': {'2','5'}, 'N': '6'},
    '2': {'R': {'5','7'}, 'N': {'1','6','3'}},
    '3': {'R': {'2','7','4'}, 'N': {'6','8'}},
    '4': {'R': '7', 'N': {'3','8'}},
    '5': {'R': {'2','10'}, 'N': {'1','6','9'}},
    '6': {'R': {'2','5','7','10'}, 'N': {'1','3','9','11'}},
    '7': {'R': {'2','4','10','12'}, 'N': {'3','6','8','11'}},
    '8': {'R': {'4','7','12'}, 'N': {'3','11'}},
    '9': {'R': {'5','10','13'}, 'N': {'6','14'}},
    '10': {'R': {'5','7','13','15'}, 'N': {'6','9','11','14'}},
    '11': {'R': {'7','10','12','15'}, 'N': {'6','8','14','16'}},
    '12': {'R': {'7','15'}, 'N': {'8','11','16'}},
    '13': {'R': '10', 'N': {'9','14'}},
    '14': {'R': {'13','10','15'}, 'N': {'9','11'}},
    '15': {'R': {'10','12'}, 'N': {'11','14','16'}},
    '16': {'R': {'12','15'}, 'N': '11'}
}

if x == "1":
    archivo_ruta = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt'
    # Abre el archivo en modo de lectura
    archivo = open(archivo_ruta, "r")

    # Lee una línea del archivo
    ruta_evaluar = archivo.readline()

    # Imprime la línea leída
    archivo_recorridos = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_blanca.txt'
    archivo_salida = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\arbol_blanca.dot'
    transiciones_posibles = []
    recorrer_estados_blanca(tablaEstados, ruta_evaluar)
    generar_arbol_recorridos(tablaEstados, ruta_evaluar, archivo_recorridos, archivo_salida)
    
else:
    #Redenrizmos ruta blanca
    archivo_ruta = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt'
    # Abre el archivo en modo de lectura
    archivo = open(archivo_ruta, "r")

    # Lee una línea del archivo
    ruta_evaluar = archivo.readline()

    # Imprime la línea leída
    archivo_recorridos = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_blanca.txt'
    archivo_salida = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\arbol_blanca.dot'
    transiciones_posibles = []
    recorrer_estados_blanca(tablaEstados, ruta_evaluar)
    generar_arbol_recorridos(tablaEstados, ruta_evaluar, archivo_recorridos, archivo_salida)
    
    #Renderizamos ruta negra
    archivo_ruta = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_negra.txt'
    # Abre el archivo en modo de lectura
    archivo = open(archivo_ruta, "r")

    # Lee una línea del archivo
    ruta_evaluar = archivo.readline()

    # Imprime la línea leída
    archivo_recorridos = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_negra.txt'
    archivo_salida = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\arbol_negra.dot'
    transiciones_posibles = []
    recorrer_estados_negra(tablaEstados, ruta_evaluar)
    generar_arbol_recorridos(tablaEstados, ruta_evaluar, archivo_recorridos, archivo_salida)
    

\end{lstlisting}


\section{graficador_grande.py}
El código main solo es el programa principal que nos redireccionara a los archivos .py correspondientes a su asignmación. \newline
\\
\begin{lstlisting}
import sys
from graphviz import Digraph

# Leer el argumento pasado desde el programa principal
x=0
if len(sys.argv) > 1:
    x=((sys.argv[1]))
    #print((x))
else:
    print("No se pasó ningún argumento.")
    sys.exit(1)

def recorrer_estados_blanca(tabla_estados, cadena):
    cont=0
    cont2=0
    def obtener_recorridos(estado_actual, simbolos_restantes, recorrido_actual, archivo_recorridos):
        nonlocal cont  # Declarar 'cont' como una variable no local
        nonlocal cont2  # Declarar 'cont' como una variable no local
        if not simbolos_restantes:
            cont=cont+1
            archivo_recorridos.write(','.join(recorrido_actual) + '.')
            if cont==1000:
                archivo_recorridos.write('\n')
                cont2=cont+cont2
                cont=0
            return
        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos(estado_siguiente,simbolos_restantes[1:],recorrido_actual + [estado_siguiente],archivo_recorridos)
                if cont2==100000:
                    #input("100 cien mil pos")
                    break

    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_blanca.txt', 'w') as archivo_recorridos:
        obtener_recorridos('1', cadena, ['1'], archivo_recorridos)

def recorrer_estados_negra(tabla_estados, cadena):
    def obtener_recorridos2(estado_actual, simbolos_restantes, recorrido_actual, archivo_recorridos):
        if not simbolos_restantes:
            archivo_recorridos.write(','.join(recorrido_actual) + '.')
            return

        simbolo = simbolos_restantes[0]
        if estado_actual in tabla_estados and simbolo in tabla_estados[estado_actual]:
            transiciones = tabla_estados[estado_actual][simbolo]

            for estado_siguiente in transiciones:
                obtener_recorridos2(estado_siguiente,simbolos_restantes[1:],recorrido_actual + [estado_siguiente],archivo_recorridos)

    with open('C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_negra.txt', 'w') as archivo_recorridos:
        obtener_recorridos2('4', cadena, ['4'], archivo_recorridos)

def agregar_recorrido_al_grafo(grafo, transicion, transiciones_posibles):
    estados = transicion.split(',')
    for i in range(len(estados) - 1):
        origen = estados[i]
        destino = estados[i+1]
        if [origen, destino] not in transiciones_posibles:
            # Obtener el símbolo asociado a la transición
            if origen in tablaEstados and 'R' in tablaEstados[origen] and destino in tablaEstados[origen]['R']:
                simbolo = 'R'
            elif origen in tablaEstados and 'N' in tablaEstados[origen] and destino in tablaEstados[origen]['N']:
                simbolo = 'N'
            else:
                simbolo = ''
            #Parte donde se calcula el simbolo asociado a la trancicion o arista/flecha, recuerda que puede ser N o R dependiendo de la tabla de estados.
            grafo.edge(origen, destino,arrowhead="normal",label=simbolo)  # Utilizamos el método 'edge' para agregar una arista
            transiciones_posibles.append([origen, destino],)
    

def generar_arbol_recorridos(tabla_estados, ruta_evaluar, archivo_recorridos, archivo_salida):
    grafo = Digraph('G', filename=archivo_salida)
    grafo.attr(rankdir='LR', size='8,5')
    grafo.graph_attr['label'] = ruta_evaluar  # Agregar título al gráfico
    # Leer los recorridos desde el archivo
    with open(archivo_recorridos, 'r') as archivo:
        # Agregar los recorridos al grafo
        transiciones_posibles = []
        for line in archivo:
            linea_aux = line.strip()
            
            for linea_aux in archivo:
                recorridos = linea_aux.strip().split('.')
                for recorrido in recorridos:
                    if recorrido:
                        agregar_recorrido_al_grafo(grafo, recorrido, transiciones_posibles)

    # Renderizar el grafo y guardar la imagen
    archivo_salida_pdf = archivo_salida.replace('.dot', '.pdf')
    grafo.render(archivo_salida_pdf, view=True)



tablaEstados = {
    '1': {'R': {'2','5'}, 'N': '6'},
    '2': {'R': {'5','7'}, 'N': {'1','6','3'}},
    '3': {'R': {'2','7','4'}, 'N': {'6','8'}},
    '4': {'R': '7', 'N': {'3','8'}},
    '5': {'R': {'2','10'}, 'N': {'1','6','9'}},
    '6': {'R': {'2','5','7','10'}, 'N': {'1','3','9','11'}},
    '7': {'R': {'2','4','10','12'}, 'N': {'3','6','8','11'}},
    '8': {'R': {'4','7','12'}, 'N': {'3','11'}},
    '9': {'R': {'5','10','13'}, 'N': {'6','14'}},
    '10': {'R': {'5','7','13','15'}, 'N': {'6','9','11','14'}},
    '11': {'R': {'7','10','12','15'}, 'N': {'6','8','14','16'}},
    '12': {'R': {'7','15'}, 'N': {'8','11','16'}},
    '13': {'R': '10', 'N': {'9','14'}},
    '14': {'R': {'13','10','15'}, 'N': {'9','11'}},
    '15': {'R': {'10','12'}, 'N': {'11','14','16'}},
    '16': {'R': {'12','15'}, 'N': '11'}
}

if x == "1":
    archivo_ruta = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt'
    # Abre el archivo en modo de lectura
    archivo = open(archivo_ruta, "r")

    # Lee una línea del archivo
    ruta_evaluar = archivo.readline()

    # Imprime la línea leída
    archivo_recorridos = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_blanca.txt'
    archivo_salida = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\arbol_blanca.dot'
    transiciones_posibles = []
    recorrer_estados_blanca(tablaEstados, ruta_evaluar)
    generar_arbol_recorridos(tablaEstados, ruta_evaluar, archivo_recorridos, archivo_salida)
    
else:
    #Redenrizmos ruta blanca
    archivo_ruta = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_blanca.txt'
    # Abre el archivo en modo de lectura
    archivo = open(archivo_ruta, "r")

    # Lee una línea del archivo
    ruta_evaluar = archivo.readline()

    # Imprime la línea leída
    archivo_recorridos = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_blanca.txt'
    archivo_salida = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\arbol_blanca.dot'
    transiciones_posibles = []
    recorrer_estados_blanca(tablaEstados, ruta_evaluar)
    generar_arbol_recorridos(tablaEstados, ruta_evaluar, archivo_recorridos, archivo_salida)
    
    #Renderizamos ruta negra
    archivo_ruta = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\ruta_negra.txt'
    # Abre el archivo en modo de lectura
    archivo = open(archivo_ruta, "r")

    # Lee una línea del archivo
    ruta_evaluar = archivo.readline()

    # Imprime la línea leída
    archivo_recorridos = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\recorridos_negra.txt'
    archivo_salida = 'C:\\Users\\soyco\\OneDrive\\Documents\\ESCOM\\sem4\\Teoria\\P2\\Chess\\output\\arbol_negra.dot'
    transiciones_posibles = []
    recorrer_estados_negra(tablaEstados, ruta_evaluar)
    generar_arbol_recorridos(tablaEstados, ruta_evaluar, archivo_recorridos, archivo_salida)
    

\end{lstlisting}